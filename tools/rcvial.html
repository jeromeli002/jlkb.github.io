<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>图片转数组代码</title>
  <style>
    /* 样式优化和自适应布局 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', 'Microsoft YaHei', sans-serif;
    }
    /* 优化: 容器宽度 90%，最大 1200px，居中，自适应 */
    .wrapper {
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      width: 90%; /* 90% 宽度 */
      max-width: 1200px;
      padding-top: 20px;
    }
    .section {
      margin: 10px 0;
    }
    .bottom-divider {
      border-bottom: 2px solid #000000;
      padding-bottom: 20px;
    }
    .sub-section {
      clear: both;
      margin-bottom: 1px;
      display: flex;
      gap: 20px;
    }
    .section,
    .sub-section {
      width: 100%;
    }
    .column {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
    }
    .column-center {
      min-width: auto;
      text-align: center;
      align-self: center;
      flex: 0 0 auto;
      padding: 0 10px;
    }
    .column-right {
      flex: 1;
    }
    /* 优化: 适应小屏幕 (第一部分：选择图像/粘贴字节数组) */
    @media (max-width: 768px) {
      .sub-section {
        flex-direction: column;
        gap: 10px;
      }
      .column-center {
        order: -1;
      }
    }

    /* 优化: Section 2, 3, 4 配置部分 - 左右两栏布局 */
    .main-config-flex-container {
      display: flex;
      gap: 20px;
      margin-top: 10px;
    }

    /* 优化重点：设置两列等宽 */
    .settings-column {
      flex: 1; /* 50% 空间给设置项 */
      min-width: 0;
    }

    .right-config-column {
      flex: 1; /* 50% 空间给预览和输出设置 */
      min-width: 0;
      display: flex;
      flex-direction: column; /* 垂直堆叠 3.预览 和 4.输出设置 */
      gap: 20px; /* 3 和 4 之间的间距 */
    }

    .settings-column .sub-section,
    .right-config-column .sub-section {
      margin-bottom: 0;
      display: block;
    }

    /* 响应式调整 for Section 2 & 3 & 4 配置 */
    @media (max-width: 900px) {
      .main-config-flex-container {
        flex-direction: column; /* 垂直堆叠 */
      }
    }

    /* 优化: 底部输出区域 - 全宽单列 */
    .output-area-full-width {
      margin-top: 20px;
    }


    .sub-section-title {
      margin: 0 0 10px;
    }
    p {
      margin: 15px 0;
      line-height: 1.6;
    }
    .table {
      display: table;
      margin: 10px 0 0;
      width: 100%;
      border-collapse: collapse;
    }
    .table-row {
      display: table-row;
      width: 100%;
    }
    .table-cell {
      display: table-cell;
      padding: 5px 10px 5px 0;
      vertical-align: top;
    }
    .table-cell:first-child {
      width: 30%;
      min-width: 100px;
      padding-left: 0;
    }
    .table-cell:last-child {
      width: 70%;
      padding-right: 0;
    }
    .table-cell:first-child label {
      font-weight: bold;
    }
    .table-cell:last-child label {
      margin-right: 10px;
    }
    .nested-table {
      margin: 0;
    }
    .nested-table .table-cell {
      color: #666;
      font-size: .9em;
      width: auto;
      min-width: 150px;
    }
    #format-caption-container div {
      color: #505050;
      display: none;
      font-size: .9em;
      line-height: 1.4em;
      padding: 10px 0 15px;
      width: 100%;
    }
    .upload-note {
      max-width: 100%;
    }
    .byte-input {
      min-height: 160px;
      width: 100%;
      padding: 5px;
    }
    /* 优化: 调整输出文本框高度，并确保在全宽容器中占满 */
    .code-output {
      height: 160px;
      width: 100%;
      padding: 5px;
    }
    .note {
      color: #666666;
      font-size: .9em;
      line-height: 1.4em;
      margin: 3px 0;
    }
    .file-input-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    button,
    input[type="file"] {
      background: #00CB99;
      border-radius: 3px;
      border: none;
      color: #fff;
      font-size: .9em;
      font-weight: bold;
      margin: 5px 5px 5px 0;
      padding: 4px 8px;
      cursor: pointer;
      transition: background-color 0.2s; /* 添加过渡效果 */
    }
    input[type="file"] {
      font-size: 1.0em;
      padding: 6px 20px;
      margin-top: 10px;
    }
    .remove-button {
      margin: 0 0 0 10px;
      padding: 1px 4px;
      background: #dc3545;
    }
    .file-info {
      color: #505050;
      font-size: .7em;
      margin-left: 20px;
      max-width: 300px;
      white-space: pre-wrap;
      display: block; /* 确保文件名信息占据一行 */
    }
    .size-input {
      width: 60px;
    }
    .glyph-input {
      width: 80px;
      margin-left: 10px;
    }
    #image-size-settings {
      list-style-type: none;
    }
    /* 优化：确保列表项内元素对齐 */
    #image-size-settings li {
      margin: 4px 0;
      display: flex;
      flex-direction: column;
    }
    #image-size-settings li > * {
        margin-right: 5px; /* 元素间距 */
    }
    #image-size-settings li .input-row {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
    }
    
    #images-canvas-container canvas {
      border: 3px solid #88DAC5;
      margin: 10px auto;
    }
    #images-canvas-container {
      align-items: flex-start;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    #arduino-identifier,
    #adafruit-gfx-settings,
    #all-same-size {
      display: none;
    }
    .msg {
      font-size: 1.2em;
    }
    .error-msg {
      color: #ff0000;
      display: none;
    }
    /* 移除绿色背景，保留样式 */
    h1 {
      padding: 15px;
      margin: 0;
      color: #00cb99;
    }
    /* 优化: 复制成功后的样式 */
    #copy-button.copy-success {
      background: #dc3545; /* 红色 */
      color: #fff;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1 style="text-align: center;">图片转数组代码</h1>

    <section class="section bottom-divider">
      <section class="sub-section">
        <div class="column" id="file-input-column">
          <h2 class="sub-section-title">1. 选择图像</h2>
          <div class="note upload-note">所有处理均在您的浏览器本地完成；您的图像不会上传或存储到任何在线位置。</div>
          <input type="file" id="file-input" name="file-input" multiple /><br />
        </div>
        <div class="column column-center">
          <h2 class="sub-section-title">或</h2>
        </div>
        <div class="column column-right">
          <h2 class="sub-section-title">1. 粘贴字节数组</h2>
          <textarea id="byte-input" class="byte-input" placeholder="在此粘贴字节数组" oninput="debounceUpdateAndGenerateForTextInput()"></textarea><br />
          <div class="text-input-size">
            <input type="number" min="0" id="text-input-width" class="size-input" value="128" oninput="debounceUpdateAndGenerateForTextInput()" /> 宽 x
            <input type="number" min="0" id="text-input-height" class="size-input" value="64" oninput="debounceUpdateAndGenerateForTextInput()" /> 高 (像素)
          </div>
          <div>
            <button onclick="handleTextInput('horizontal', true)">按水平模式读取</button>
            <button onclick="handleTextInput('vertical', true)">按垂直模式读取</button>
          </div>
          <div class="note">读取的图像将显示在下方的第 3 步预览中</div>
        </div>
      </section>
    </section>

    <section class="section bottom-divider">
      <div class="main-config-flex-container">
        <div class="settings-column">
          <h2 class="sub-section-title">2. 图像设置</h2>
          <section class="sub-section" style="display: block;">
            <div class="table">

              <div class="table-row">
                <div class="table-cell"><label>画布尺寸： </label></div>
                <div class="table-cell">
                  <ul id="image-size-settings"></ul>
                  <div id="only-images-file-error" class="msg error-msg">只允许图像文件类型</div>
                  <div class="no-file-selected" class="msg">未选择文件</div>
                  <button id="all-same-size" onclick="allSameSize()">将第一张图像的尺寸应用于所有图像</button>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label>背景颜色：</label></div>
                <div class="table-cell">
                  <input id="backgroundColorWhite" type="radio" name="backgroundColor" value="white" checked="checked" onchange="updateRadio('backgroundColor')" />
                  <label for="backgroundColorWhite" class="smallLabel">白色</label>
                  <input id="backgroundColorBlack" type="radio" name="backgroundColor" value="black" onchange="updateRadio('backgroundColor')" />
                  <label for="backgroundColorBlack" class="smallLabel">黑色</label>
                  <input id="backgroundColorTransparent" type="radio" name="backgroundColor" value="transparent" onchange="updateRadio('backgroundColor')" />
                  <label for="backgroundColorTransparent" class="smallLabel">透明</label>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label for="invertColors">反转图像颜色</label></div>
                <div class="table-cell">
                  <input id="invertColors" type="checkbox" onchange="updateBoolean('invertColors')" />
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label for="ditheringMode">抖动算法： </label></div>
                <div class="table-cell">
                  <select id="ditheringMode" onchange="updateInteger('ditheringMode')">
                    <option value="0">Binary (二值化)</option>
                    <option value="1">Bayer (拜耳)</option>
                    <option value="2">Floyd-Steinberg (弗洛伊德-斯坦伯格)</option>
                    <option value="3">Atkinson (阿特金森)</option>
                  </select>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label for="ditheringThreshold">亮度/Alpha 阈值： </label></div>
                <div class="table-cell">
                  <input id="ditheringThreshold" class="size-input" type="number" min="0" max="255" name="ditheringThreshold" oninput="debounceUpdateInteger('ditheringThreshold')" value="128" />
                  <div class="note">
                    <i>0 - 255；如果像素亮度高于此值则变为白色，否则变为黑色。使用 Alpha 通道时，则用不透明和透明代替。</i>
                  </div>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label for="scale">缩放：</label></div>
                <div class="table-cell">
                  <select id="scale" name="scale" onchange="updateInteger('scale')">
                    <option value="1">原始尺寸</option>
                    <option value="2">按比例缩放以适应画布</option>
                    <option value="3">拉伸以填充画布</option>
                    <option value="4">水平拉伸以填充画布</option>
                    <option value="5">垂直拉伸以填充画布</option>
                  </select>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label>居中图像：</label></div>
                <div class="table-cell">
                  <input id="centerHorizontally" type="checkbox" onchange="updateBoolean('centerHorizontally')" />
                  <label for="centerHorizontally">水平</label>
                  <input id="centerVertically" type="checkbox" onchange="updateBoolean('centerVertically')" />
                  <label for="centerVertically">垂直</label>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"></div>
                <div class="table-cell">
                  <i class="note">仅当画布尺寸大于原始图像时，居中才有效。</i>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label for="rotation">旋转图像：</label></div>
                <div class="table-cell">
                  <select id="rotation" name="rotation" onchange="updateInteger('rotation')">
                    <option value="0">0</option>
                    <option value="90">90</option>
                    <option value="180">180</option>
                    <option value="270">270</option>
                  </select>
                  <label for="rotation">度</label>
                </div>
              </div>

              <div class="table-row">
                <div class="table-cell"><label>翻转图像：</label></div>
                <div class="table-cell">
                  <input id="flipHorizontally" type="checkbox" onchange="updateBoolean('flipHorizontally')" />
                  <label for="flipHorizontally">水平翻转</label>
                  <input id="flipVertically" type="checkbox" onchange="updateBoolean('flipVertically')" />
                  <label for="flipVertically">垂直翻转</label>
                </div>
              </div>

            </div>
          </section>
        </div>

        <div class="right-config-column">
          <div>
            <h2 class="sub-section-title">3. 预览</h2>
            <section class="sub-section" style="display: block;">
              <div class="no-file-selected" class="msg">未选择文件</div>
              <div id="images-canvas-container"></div>
            </section>
          </div>

          <div>
            <h2 class="sub-section-title">4. 输出设置</h2>
            <section class="sub-section" style="display: block;">
              <div class="table">
                <div class="table-row">
                  <div class="table-cell"><label for="outputFormat">代码输出格式</label></div>
                  <div class="table-cell">
                    <select id="outputFormat" name="outputFormat" onchange="updateOutputFormat(this)">
                      <option value="plain">纯字节数组</option>
                      <option value="arduino">Arduino 代码</option>
                      <option value="arduino_single">Arduino 代码, 单个位图</option>
                      <option value="adafruit_gfx">Adafruit GFX 位图字体</option>
                    </select>
                    <div id="format-caption-container">
                      <div data-caption="arduino">
                        在输出周围添加额外的 Arduino 代码，方便复制粘贴到
                        <a href="https://github.com/javl/image2cpp/blob/master/oled_example/oled_example.ino" target="_blank">此示例</a>。
                        如果加载了多张图像，则为每张图像生成一个字节数组，并向标识符附加计数器。
                      </div>
                      <div data-caption="arduino_single">
                        在输出周围添加额外的 Arduino 代码，方便复制粘贴。
                        如果加载了多张图像，则生成一个单独的字节数组。
                      </div>
                      <div data-caption="adafruit_gfx">
                        创建 <code>GFXbitmapFont</code> 格式的输出。用于 Adafruit GFX 库的修改版本。
                        GitHub 项目和示例请见 <a href="https://github.com/wiredolphin/Adafruit-GFX-Library/tree/bitmap-font" target="_blank">此处</a>。
                        <br />
                        <i>第一个 ASCII 字符</i> 值仅在未给每张图像提供长度为 1 的字形标识符时使用。该值将为每个字形递增 1。
                      </div>
                    </div>
                    <div id="extra-settings-container">
                      <div id="adafruit-gfx-settings" class="table nested-table">
                        <div class="table-row">
                          <div class="table-cell"><label>第一个 ASCII 字符 (十进制):</label></div>
                          <div class="table-cell">
                            <input id="first-ascii-char" class="text-input" type="number" name="first-ascii-char" oninput="debounceUpdateInteger('first-ascii-char')" value="48" />
                          </div>
                        </div>
                        <div class="table-row">
                          <div class="table-cell"><label>X 步进:</label></div>
                          <div class="table-cell">
                            <input id="x-advance" class="text-input" type="number" name="x-advance" oninput="debounceUpdateInteger('x-advance')" value="0" />
                          </div>
                        </div>
                      </div>
                      <div id="arduino-identifier" class="table nested-table">
                        <div class="table-row">
                          <div class="table-cell"><label>标识符/前缀:</label></div>
                          <div class="table-cell">
                            <input id="identifier" class="text-input" type="text" name="identifier" oninput="debounceUpdateAndGenerate()" value="epd_bitmap_" />
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="table-row">
                  <div class="table-cell"><label for="drawMode">绘制模式:</label></div>
                  <div class="table-cell">
                    <select id="drawMode" name="drawMode" onchange="updateDrawMode(this)">
                      <option value="horizontal1bit">水平 - 1 位/像素</option>
                      <option value="vertical1bit">垂直 - 1 位/像素</option>
                      <option value="horizontal565">水平 - 2 字节/像素 (565)</option>
                      <option value="horizontalAlpha">水平 - 1 位/像素 Alpha 掩码</option>
                      <option value="horizontal888">水平 - 3 字节/像素 (rgb888)</option>
                    </select>

                    <div class="note">
                      <i>如果您的图像在显示器上看起来一团糟，如下面的图像所示，请尝试使用不同的模式。</i>
                    </div>
                    <img class="inlineImg"
                      src="data:image/jpeg;base64,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"
                      width="150" height="64" alt="" />

                  </div>
                </div>

                <div class="table-row">
                  <div class="table-cell"><label for="bitswap">字节内比特位交换:</label></div>
                  <div class="table-cell">
                    <input id="bitswap" type="checkbox" onchange="updateBoolean('bitswap')">
                    <label for="bitswap">交换</label>
                  </div>
                </div>

                <div class="table-row">
                  <div class="table-cell"></div>
                  <div class="table-cell">
                    <i class="note">使用 u8g2 库时很有用。</i>
                  </div>
                </div>


                <div class="table-row" id="remove-zeroes-commas-container">
                  <div class="table-cell"><label>额外格式化选项:</label></div>
                  <div class="table-cell">
                    <input id="removeZeroesCommas" type="checkbox" onchange="updateBoolean('removeZeroesCommas')" />
                    <label for="removeZeroesCommas">从输出中移除 '0x' 和逗号</label>
                  </div>
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>
    </section>

    <section class="section output-area-full-width">
      <h2>输出代码</h2>
      <section class="sub-section" style="display: block; margin-bottom: 0;">
        <button type="button" id="generate-button" onclick="manualGenerateCode()">生成代码</button>
        <button type="button" id="copy-button" onclick="copyOutput()">复制输出</button>
        <button type="button" id="download-button" onclick="downloadBinFile()">下载为二进制文件 (.bin)</button>
        <button type="button" id="download-code-button" onclick="downloadCodeFile()">下载代码 (.c)</button>
        <textarea id="code-output" class="code-output" placeholder="生成的代码将显示在此处..."></textarea>
      </section>
    </section>
  </div>

  <script>
    // -------------------------------------------------------------------------
    // Dithering and Utility Functions (dithering.js 内容)
    // -------------------------------------------------------------------------
    /* eslint-disable no-plusplus */
    const bwrPalette = [
      [0, 0, 0, 255],
      [255, 255, 255, 255],
      [255, 0, 0, 255],
    ];

    const bwPalette = [
      [0, 0, 0, 255],
      [255, 255, 255, 255],
    ];

    function dithering(ctx, width, height, threshold, typeIndex) {
      const type = ['binary', 'bayer', 'floydsteinberg', 'atkinson'][typeIndex];
      const bayerThresholdMap = [
        [15, 135, 45, 165],
        [195, 75, 225, 105],
        [60, 180, 30, 150],
        [240, 120, 210, 90],
      ];

      const lumR = [];
      const lumG = [];
      const lumB = [];
      for (let i = 0; i < 256; i++) {
        lumR[i] = i * 0.299;
        lumG[i] = i * 0.587;
        lumB[i] = i * 0.114;
      }
      const imageData = ctx.getImageData(0, 0, width, height);

      const imageDataLength = imageData.data.length;

      // Greyscale luminance (sets r pixels to luminance of rgb)
      for (let i = 0; i <= imageDataLength; i += 4) {
        imageData.data[i] =
          Math.floor(lumR[imageData.data[i]] + lumG[imageData.data[i + 1]] + lumB[imageData.data[i + 2]]);
      }

      const w = imageData.width;
      let newPixel; let
        err;

      for (let currentPixel = 0; currentPixel <= imageDataLength; currentPixel += 4) {
        if (type === 'binary') {
          // No dithering
          imageData.data[currentPixel] = imageData.data[currentPixel] < threshold ? 0 : 255;
        } else if (type === 'bayer') {
          // 4x4 Bayer ordered dithering algorithm
          // eslint-disable-next-line no-mixed-operators
          const x = currentPixel / 4 % w;
          const y = Math.floor(currentPixel / 4 / w);
          const map = Math.floor((imageData.data[currentPixel] + bayerThresholdMap[x % 4][y % 4]) / 2);
          imageData.data[currentPixel] = (map < threshold) ? 0 : 255;
        } else if (type === 'floydsteinberg') {
          // Floyda€"Steinberg dithering algorithm
          newPixel = imageData.data[currentPixel] < 129 ? 0 : 255;
          err = Math.floor((imageData.data[currentPixel] - newPixel) / 16);
          imageData.data[currentPixel] = newPixel;

          imageData.data[currentPixel + 4] += err * 7;
          imageData.data[currentPixel + 4 * w - 4] += err * 3;
          imageData.data[currentPixel + 4 * w] += err * 5;
          imageData.data[currentPixel + 4 * w + 4] += err * 1;
        } else if (type === 'atkinson') {
          // Bill Atkinson's dithering algorithm
          newPixel = imageData.data[currentPixel] < threshold ? 0 : 255;
          err = Math.floor((imageData.data[currentPixel] - newPixel) / 8);
          imageData.data[currentPixel] = newPixel;

          imageData.data[currentPixel + 4] += err;
          imageData.data[currentPixel + 8] += err;
          imageData.data[currentPixel + 4 * w - 4] += err;
          imageData.data[currentPixel + 4 * w] += err;
          imageData.data[currentPixel + 4 * w + 4] += err;
          imageData.data[currentPixel + 8 * w] += err;
        } else {
          console.error(`unknown dithering type requested: ${type}`);
        }

        // Set g and b pixels equal to r
        imageData.data[currentPixel + 1] = imageData.data[currentPixel + 2] = imageData.data[currentPixel];
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function canvas2bytes(canvas, type = 'bw') {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const arr = [];
      let buffer = [];

      for (let x = canvas.width - 1; x >= 0; x--) {
        for (let y = 0; y < canvas.height; y++) {
          const index = (canvas.width * 4 * y) + x * 4;
          if (type !== 'bwr') {
            buffer.push(imageData.data[index] > 0 && imageData.data[index + 1] > 0 && imageData.data[index + 2] > 0 ? 1 : 0);
          } else {
            buffer.push(imageData.data[index] > 0 && imageData.data[index + 1] === 0 && imageData.data[index + 2] === 0 ? 1 : 0);
          }

          if (buffer.length === 8) {
            arr.push(parseInt(buffer.join(''), 2));
            buffer = [];
          }
        }
      }
      return arr;
    }

    function getColorDistance(rgba1, rgba2) {
      const [r1, b1, g1] = rgba1;
      const [r2, b2, g2] = rgba2;

      const rm = (r1 + r2) / 2;

      const r = r1 - r2;
      const g = g1 - g2;
      const b = b1 - b2;

      return Math.sqrt((2 + rm / 256) * r * r + 4 * g * g + (2 + (255 - rm) / 256) * b * b);
    }

    function getNearColor(pixel, palette) {
      let minDistance = 255 * 255 * 3 + 1;
      let paletteIndex = 0;

      for (let i = 0; i < palette.length; i++) {
        const targetColor = palette[i];
        const distance = getColorDistance(pixel, targetColor);
        if (distance < minDistance) {
          minDistance = distance;
          paletteIndex = i;
        }
      }

      return palette[paletteIndex];
    }

    function getNearColorV2(color, palette) {
      let minDistanceSquared = 255 * 255 + 255 * 255 + 255 * 255 + 1;

      let bestIndex = 0;
      for (let i = 0; i < palette.length; i++) {
        const rdiff = (color[0] & 0xff) - (palette[i][0] & 0xff);
        const gdiff = (color[1] & 0xff) - (palette[i][1] & 0xff);
        const bdiff = (color[2] & 0xff) - (palette[i][2] & 0xff);
        const distanceSquared = rdiff * rdiff + gdiff * gdiff + bdiff * bdiff;
        if (distanceSquared < minDistanceSquared) {
          minDistanceSquared = distanceSquared;
          bestIndex = i;
        }
      }
      return palette[bestIndex];
    }

    function updatePixel(imageData, index, color) {
      imageData[index] = color[0];
      imageData[index + 1] = color[1];
      imageData[index + 2] = color[2];
      imageData[index + 3] = color[3];
    }

    function getColorErr(color1, color2, rate) {
      const res = [];
      for (let i = 0; i < 3; i++) {
        res.push(Math.floor((color1[i] - color2[i]) / rate));
      }
      return res;
    }

    function updatePixelErr(imageData, index, err, rate) {
      imageData[index] += err[0] * rate;
      imageData[index + 1] += err[1] * rate;
      imageData[index + 2] += err[2] * rate;
    }

    function ditheringCanvasByPalette(canvas, palette, type) {
      palette = palette || bwrPalette;

      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const w = imageData.width;

      for (let currentPixel = 0; currentPixel <= imageData.data.length; currentPixel += 4) {
        const newColor = getNearColorV2(imageData.data.slice(currentPixel, currentPixel + 4), palette);

        if (type === 'bwr_floydsteinberg') {
          const err = getColorErr(imageData.data.slice(currentPixel, currentPixel + 4), newColor, 16);

          updatePixel(imageData.data, currentPixel, newColor);
          updatePixelErr(imageData.data, currentPixel + 4, err, 7);
          updatePixelErr(imageData.data, currentPixel + 4 * w - 4, err, 3);
          updatePixelErr(imageData.data, currentPixel + 4 * w, err, 5);
          updatePixelErr(imageData.data, currentPixel + 4 * w + 4, err, 1);
        } else {
          const err = getColorErr(imageData.data.slice(currentPixel, currentPixel + 4), newColor, 8);

          updatePixel(imageData.data, currentPixel, newColor);
          updatePixelErr(imageData.data, currentPixel + 4, err, 1);
          updatePixelErr(imageData.data, currentPixel + 8, err, 1);
          updatePixelErr(imageData.data, currentPixel + 4 * w - 4, err, 1);
          updatePixelErr(imageData.data, currentPixel + 4 * w, err, 1);
          updatePixelErr(imageData.data, currentPixel + 4 * w + 4, err, 1);
          updatePixelErr(imageData.data, currentPixel + 8 * w, err, 1);
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // -------------------------------------------------------------------------
    // Main Script (script.js 内容)
    // -------------------------------------------------------------------------
    /* eslint-disable radix */
    /* eslint-disable max-len */
    /* eslint-disable no-plusplus */
    // A bunch of settings used when converting
    const settings = {
      screenWidth: 128,
      screenHeight: 64,
      scaleToFit: true,
      preserveRatio: true,
      centerHorizontally: false,
      centerVertically: false,
      flipHorizontally: false,
      flipVertically: false,
      backgroundColor: 'white',
      scale: 1,
      drawMode: 'horizontal',
      removeZeroesCommas: false,
      ditheringThreshold: 128,
      ditheringMode: 0,
      outputFormat: 'plain',
      invertColors: false,
      rotation: 0,
    };

    function bitswap(b) {
      if (settings.bitswap) {
        // eslint-disable-next-line no-bitwise, no-mixed-operators, no-param-reassign
        b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
        // eslint-disable-next-line no-bitwise, no-mixed-operators, no-param-reassign
        b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
        // eslint-disable-next-line no-bitwise, no-mixed-operators, no-param-reassign
        b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
      }
      return b;
    }

    const ConversionFunctions = {
      // Output the image as a string for horizontally drawing displays
      horizontal1bit(data, canvasWidth) {
        let stringFromBytes = '';
        let outputIndex = 0;
        let byteIndex = 7;
        let number = 0;

        // format is RGBA, so move 4 steps per pixel
        for (let index = 0; index < data.length; index += 4) {
          // Get the average of the RGB (we ignore A)
          const avg = (data[index] + data[index + 1] + data[index + 2]) / 3;
          if (avg > settings.ditheringThreshold) {
            number += 2 ** byteIndex;
          }
          byteIndex--;

          // if this was the last pixel of a row or the last pixel of the
          // image, fill up the rest of our byte with zeros so it always contains 8 bits
          if ((index !== 0 && (((index / 4) + 1) % (canvasWidth)) === 0) || (index === data.length - 4)) {
            // for(var i=byteIndex;i>-1;i--){
            // number += Math.pow(2, i);
            // }
            byteIndex = -1;
          }

          // When we have the complete 8 bits, combine them into a hex value
          if (byteIndex < 0) {
            let byteSet = bitswap(number).toString(16);
            if (byteSet.length === 1) { byteSet = `0${byteSet}`; }
            if (!settings.removeZeroesCommas) {
              stringFromBytes += `0x${byteSet}, `;
            } else {
              stringFromBytes += byteSet;
            }
            outputIndex++;
            if (outputIndex >= 16) {
              if (!settings.removeZeroesCommas) {
                stringFromBytes += '\n';
              }
              outputIndex = 0;
            }
            number = 0;
            byteIndex = 7;
          }
        }
        return stringFromBytes;
      },

      // Output the image as a string for vertically drawing displays
      // eslint-disable-next-line no-unused-vars
      vertical1bit(data, canvasWidth) {
        let stringFromBytes = '';
        let outputIndex = 0;
        for (let p = 0; p < Math.ceil(settings.screenHeight / 8); p++) {
          for (let x = 0; x < settings.screenWidth; x++) {
            let byteIndex = 7;
            let number = 0;

            for (let y = 7; y >= 0; y--) {
              const index = ((p * 8) + y) * (settings.screenWidth * 4) + x * 4;
              const avg = (data[index] + data[index + 1] + data[index + 2]) / 3;
              if (avg > settings.ditheringThreshold) {
                number += 2 ** byteIndex;
              }
              byteIndex--;
            }
            let byteSet = bitswap(number).toString(16);
            if (byteSet.length === 1) { byteSet = `0${byteSet}`; }
            if (!settings.removeZeroesCommas) {
              stringFromBytes += `0x${byteSet.toString(16)}, `;
            } else {
              stringFromBytes += byteSet.toString(16);
            }
            outputIndex++;
            if (outputIndex >= 16) {
              stringFromBytes += '\n';
              outputIndex = 0;
            }
          }
        }
        return stringFromBytes;
      },

      // Output the image as a string for 565 displays (horizontally)
      // eslint-disable-next-line no-unused-vars
      horizontal565(data, canvasWidth) {
        let stringFromBytes = '';
        let outputIndex = 0;

        // format is RGBA, so move 4 steps per pixel
        for (let index = 0; index < data.length; index += 4) {
          // Get the RGB values
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          // calculate the 565 color value
          // eslint-disable-next-line no-bitwise
          const rgb = ((r & 0b11111000) << 8) | ((g & 0b11111100) << 3) | ((b & 0b11111000) >> 3);
          // Split up the color value in two bytes
          // const firstByte = (rgb >> 8) & 0xff;
          // const secondByte = rgb & 0xff;

          let byteSet = bitswap(rgb).toString(16);
          while (byteSet.length < 4) { byteSet = `0${byteSet}`; }
          if (!settings.removeZeroesCommas) {
            stringFromBytes += `0x${byteSet}, `;
          } else {
            stringFromBytes += byteSet;
          }
          // add newlines every 16 bytes
          outputIndex++;
          if (outputIndex >= 16) {
            stringFromBytes += '\n';
            outputIndex = 0;
          }
        }
        return stringFromBytes;
      },
      // Output the image as a string for rgb888 displays (horizontally)
      horizontal888(data, canvasWidth) {
        let stringFromBytes = '';
        let outputIndex = 0;

        // format is RGBA, so move 4 steps per pixel
        for (let index = 0; index < data.length; index += 4) {
          // Get the RGB values
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          // calculate the 565 color value
          // eslint-disable-next-line no-bitwise
          const rgb = (r << 16) | (g << 8) | (b);
          // Split up the color value in two bytes
          // const firstByte = (rgb >> 8) & 0xff;
          // const secondByte = rgb & 0xff;

          let byteSet = bitswap(rgb).toString(16);
          while (byteSet.length < 8) { byteSet = `0${byteSet}`; }
          if (!settings.removeZeroesCommas) {
            stringFromBytes += `0x${byteSet}, `;
          } else {
            stringFromBytes += byteSet;
          }

          // add newlines every 16 bytes
          outputIndex++;
          if (outputIndex >= canvasWidth) {
            stringFromBytes += '\n';
            outputIndex = 0;
          }
        }
        return stringFromBytes;
      },
      // Output the alpha mask as a string for horizontally drawing displays
      horizontalAlpha(data, canvasWidth) {
        let stringFromBytes = '';
        let outputIndex = 0;
        let byteIndex = 7;
        let number = 0;

        // format is RGBA, so move 4 steps per pixel
        for (let index = 0; index < data.length; index += 4) {
          // Get alpha part of the image data
          const alpha = data[index + 3];
          if (alpha > settings.ditheringThreshold) {
            number += 2 ** byteIndex;
          }
          byteIndex--;

          // if this was the last pixel of a row or the last pixel of the
          // image, fill up the rest of our byte with zeros so it always contains 8 bits
          if ((index !== 0 && (((index / 4) + 1) % (canvasWidth)) === 0) || (index === data.length - 4)) {
            byteIndex = -1;
          }

          // When we have the complete 8 bits, combine them into a hex value
          if (byteIndex < 0) {
            let byteSet = bitswap(number).toString(16);
            if (byteSet.length === 1) { byteSet = `0${byteSet}`; }
            if (!settings.removeZeroesCommas) {
              stringFromBytes += `0x${byteSet}, `;
            } else {
              stringFromBytes += byteSet;
            }
            outputIndex++;
            if (outputIndex >= 16) {
              stringFromBytes += '\n';
              outputIndex = 0;
            }
            number = 0;
            byteIndex = 7;
          }
        }
        return stringFromBytes;
      },
    };
    settings.conversionFunction = ConversionFunctions.horizontal1bit;

    // An images collection with helper methods
    function Images() {
      const collection = [];
      this.push = (img, canvas, glyph) => { collection.push({ img, canvas, glyph }); };
      this.remove = (image) => {
        const i = collection.indexOf(image);
        if (i !== -1) collection.splice(i, 1);
      };
      this.each = (f) => { collection.forEach(f); };
      this.length = () => collection.length;
      this.first = () => collection[0];
      this.last = () => collection[collection.length - 1];
      this.getByIndex = (index) => collection[index];
      this.setByIndex = (index, img) => { collection[index] = img; };
      this.get = (img) => {
        if (img) {
          for (let i = 0; i < collection.length; i++) {
            if (collection[i].img === img) {
              return collection[i];
            }
          }
        }
        return collection;
      };
      return this;
    }

    const images = new Images();
    // Filetypes accepted by the file picker
    // const fileTypes = ['jpg', 'jpeg', 'png', 'bmp', 'gif', 'svg'];
    // Variable name, when "arduino code" is required
    const identifier = 'myBitmap';
    
    // =========================================================================
    // 实时更新控制函数
    // =========================================================================
    let updateTimer;
    let lastDrawMode = 'horizontal'; // 新增：保存粘贴的默认读取模式
    
    function debounceUpdateAndGenerate() {
        // 清除任何待处理的更新，以防止快速、不必要的重新生成
        clearTimeout(updateTimer);

        // 使用 100ms 防抖来处理快速的输入变化（如文本输入）
        updateTimer = setTimeout(() => {
            updateAllImages(); // 更新预览 Canvas
            generateOutputString(); // 生成代码
        }, 100);
    }
    
    // 专门用于处理文本输入和尺寸输入框的防抖函数
    function debounceUpdateAndGenerateForTextInput() {
        const byteInput = document.getElementById('byte-input');
        
        // 只有在文本框有内容时才尝试解析并创建图像
        if (byteInput.value.trim() !== '') {
            // 使用上次设置的模式（默认为'horizontal'）来解析字节数组并创建图像
            // 第3个参数为 true 表示是自动/防抖触发
            handleTextInput(lastDrawMode, false, true); 
        } else {
             // 如果内容为空，清空预览和输出
            const canvasContainer = document.getElementById('images-canvas-container');
            canvasContainer.innerHTML = '';
            // 检查第一个图像是否是粘贴数据，如果是则移除
            if (images.length() > 0 && images.first().glyph === 'pasted_data') {
                images.remove(images.first()); 
            }
            document.getElementById('code-output').value = '请先选择或粘贴图像数据。';
        }
        
        // 触发自动代码生成
        debounceUpdateAndGenerate(); 
    }
    
    // 为 input[type="text"]/input[type="number"] 实时输入添加防抖
    function debounceUpdateInteger(fieldName) {
        settings[fieldName] = parseInt(document.getElementById(fieldName).value);
        debounceUpdateAndGenerate();
    }
    
    // 手动触发生成代码的函数
    function manualGenerateCode() {
        updateAllImages(); // 强制更新所有 Canvas
        generateOutputString(); // 立即生成代码
    }
    // =========================================================================


    // Invert the colors of the canvas
    function invert(canvas, ctx) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const { data } = imageData;
      for (let i = 0; i < data.length; i += 4) {
        data[i] = 255 - data[i]; // red
        data[i + 1] = 255 - data[i + 1]; // green
        data[i + 2] = 255 - data[i + 2]; // blue
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // Draw the image onto the canvas, taking into account color and scaling
    function placeImage(_image) {
      const { img } = _image;
      const { canvas } = _image;
      const ctx = canvas.getContext('2d');

      // reset canvas size
      canvas.width = settings.screenWidth;
      canvas.height = settings.screenHeight;
      // eslint-disable-next-line no-param-reassign
      _image.ctx = ctx;
      ctx.save();

      // Draw background
      if (settings.backgroundColor === 'transparent') {
        ctx.fillStyle = 'rgba(0,0,0,0.0)';
        ctx.globalCompositeOperation = 'copy';
      } else {
        if (settings.invertColors) {
          if (settings.backgroundColor === 'white') {
            ctx.fillStyle = 'black';
          } else {
            ctx.fillStyle = 'white';
          }
        } else {
          ctx.fillStyle = settings.backgroundColor;
        }
        ctx.globalCompositeOperation = 'source-over';
      }
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Offset used for centering the image when requested
      let offsetX = 0;
      let offsetY = 0;
      const imgW = img.width;
      const imgH = img.height;

      switch (settings.scale) {
        case 1: // Original
          if (settings.centerHorizontally) {
            offsetX = Math.round((canvas.width - imgW) / 2);
          }
          if (settings.centerVertically) {
            offsetY = Math.round((canvas.height - imgH) / 2);
          }
          ctx.drawImage(
            img,
            0,
            0,
            imgW,
            imgH,
            offsetX,
            offsetY,
            imgW,
            imgH,
          );
          break;
        case 2: {
          // Fit (make as large as possible without changing ratio)
          const useRatio = Math.min(canvas.width / imgW, canvas.height / imgH);
          if (settings.centerHorizontally) {
            offsetX = Math.round((canvas.width - imgW * useRatio) / 2);
          }
          if (settings.centerVertically) {
            offsetY = Math.round((canvas.height - imgH * useRatio) / 2);
          }

          ctx.drawImage(
            img,
            0,
            0,
            imgW,
            imgH,
            offsetX,
            offsetY,
            imgW * useRatio,
            imgH * useRatio,
          );
          break;
        }
        case 3: // Stretch x+y (make as large as possible without keeping ratio)
          ctx.drawImage(
            img,
            0,
            0,
            imgW,
            imgH,
            offsetX,
            offsetY,
            canvas.width,
            canvas.height,
          );
          break;
        case 4: // Stretch x (make as wide as possible)
          offsetX = 0;
          if (settings.centerVertically) { Math.round(offsetY = (canvas.height - imgH) / 2); }
          // offsetY *= offsetY_dir;
          ctx.drawImage(
            img,
            0,
            0,
            imgW,
            imgH,
            offsetX,
            offsetY,
            canvas.width,
            imgH,
          );
          break;
        case 5: // Stretch y (make as tall as possible)
          if (settings.centerHorizontally) { offsetX = Math.round((canvas.width - imgW) / 2); }
          // offsetX *= offsetX_dir;
          offsetY = 0;
          ctx.drawImage(
            img,
            0,
            0,
            imgW,
            imgH,
            offsetX,
            offsetY,
            imgW,
            canvas.height,
          );
          break;
        default:
          // console.log('unknown scale');
          break;
      }
      ctx.restore();

      if (settings.conversionFunction === ConversionFunctions.horizontal1bit
        || settings.conversionFunction === ConversionFunctions.vertical1bit) {
        // eslint-disable-next-line no-undef
        dithering(ctx, canvas.width, canvas.height, settings.ditheringThreshold, settings.ditheringMode);
        if (settings.invertColors) {
          invert(canvas, ctx);
        }
      }

      if (settings.rotation !== 0) {
        const clone = canvas.cloneNode(true);
        clone.getContext('2d').drawImage(canvas, 0, 0);
        ctx.fillStyle = 'red';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (settings.rotation === 90) {
          canvas.width = settings.screenHeight;
          canvas.height = settings.screenWidth;
          ctx.setTransform(1, 0, 0, 1, canvas.width, 0);
          ctx.rotate(Math.PI / 2);
          ctx.drawImage(clone, 0, 0);
        } else if (settings.rotation === 180) {
          ctx.setTransform(1, 0, 0, 1, canvas.width, canvas.height);
          ctx.rotate(Math.PI);
          ctx.drawImage(clone, 0, 0);
        } else if (settings.rotation === 270) {
          canvas.width = settings.screenHeight;
          canvas.height = settings.screenWidth;
          ctx.setTransform(1, 0, 0, 1, 0, canvas.height);
          ctx.rotate(Math.PI * 1.5);
          ctx.drawImage(clone, 0, 0);
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }

      const flipHorizontal = settings.flipHorizontally ? -1 : 1;
      const xOffset = settings.flipHorizontally ? canvas.width : 0;
      const flipVertical = settings.flipVertically ? -1 : 1;
      const yOffset = settings.flipVertically ? canvas.height : 0;

      if (flipHorizontal === -1 || flipVertical === -1) {
        const clone = canvas.cloneNode(true);
        clone.getContext('2d').drawImage(canvas, 0, 0);
        ctx.setTransform(flipHorizontal, 0, 0, flipVertical, xOffset, yOffset); // set the scale and position
        ctx.drawImage(clone, 0, 0);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
    }

    // Handle drawing each of our images
    function updateAllImages() {
      images.each((image) => {
        placeImage(image);
      });
      // 自动生成代码已在 debounceUpdateAndGenerate 中调用
    }

    // Easy way to update settings controlled by a textfield
    function updateInteger(fieldName) {
      settings[fieldName] = parseInt(document.getElementById(fieldName).value);
      // 调用实时更新
      debounceUpdateAndGenerate();
    }

    // Easy way to update settings controlled by a checkbox
    // eslint-disable-next-line no-unused-vars
    function updateBoolean(fieldName) {
      settings[fieldName] = document.getElementById(fieldName).checked;
      // 调用实时更新
      debounceUpdateAndGenerate();
    }

    // Convert hex to binary
    function hexToBinary(s) {
      let i;
      let ret = '';
      // lookup table for easier conversion. "0" characters are padded for "1" to "7"
      const lookupTable = {
        0: '0000',
        1: '0001',
        2: '0010',
        3: '0011',
        4: '0100',
        5: '0101',
        6: '0110',
        7: '0111',
        8: '1000',
        9: '1001',
        a: '1010',
        b: '1011',
        c: '1100',
        d: '1101',
        e: '1110',
        f: '1111',
        A: '1010',
        B: '1011',
        C: '1100',
        D: '1101',
        E: '1110',
        F: '1111',
      };
      for (i = 0; i < s.length; i += 1) {
        // eslint-disable-next-line no-prototype-builtins
        if (lookupTable.hasOwnProperty(s[i])) {
          ret += lookupTable[s[i]];
        } else {
          return { valid: false, s };
        }
      }
      return { valid: true, result: ret };
    }

    // get the type (in arduino code) of the output image
    // this is a bit of a hack, it's better to make this a property of the conversion function (should probably turn it into objects)
    function getImageType() {
      if (settings.conversionFunction === ConversionFunctions.horizontal565) {
        return 'uint16_t';
      } if (settings.conversionFunction === ConversionFunctions.horizontal888) {
        return 'unsigned long';
      }
      return 'unsigned char';
    }

    // Use the horizontally oriented list to draw the image
    function listToImageHorizontal(list, canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const imgData = ctx.createImageData(canvas.width, canvas.height);
      let index = 0;

      // round the width up to the next byte
      const widthRoundedUp = Math.floor(canvas.width / 8 + (canvas.width % 8 ? 1 : 0)) * 8;
      let widthCounter = 0;

      // Move the list into the imageData object
      for (let i = 0; i < list.length; i++) {
        let binString = hexToBinary(list[i]);
        if (!binString.valid) {
          // eslint-disable-next-line no-console
          // 修复：不直接 return，而是跳过错误字节，避免整个图像空白
          console.error('invalid hexToBinary: ', binString.s);
          continue; 
        }
        binString = binString.result;
        if (binString.length === 4) {
          binString += '0000';
        }

        // Check if pixel is white or black
        for (let k = 0; k < binString.length; k++, widthCounter++) {
          // if we've counted enough bits, reset counter for next line
          if (widthCounter >= widthRoundedUp) {
            widthCounter = 0;
          }
          // skip 'artifact' pixels due to rounding up to a byte
          if (widthCounter < canvas.width) {
            let color = 0;
            if (binString.charAt(k) === '1') {
              color = 255;
            }
            imgData.data[index] = color;
            imgData.data[index + 1] = color;
            imgData.data[index + 2] = color;
            imgData.data[index + 3] = 255;

            index += 4;
          }
        }
      }

      // Draw the image onto the canvas, then save the canvas contents
      // inside the img object. This way we can reuse the img object when
      // we want to scale / invert, etc.
      ctx.putImageData(imgData, 0, 0);
      const img = new Image();
      img.src = canvas.toDataURL('image/png');
      images.first().img = img;
    }

    // Quick and effective way to draw single pixels onto the canvas
    // using a global 1x1px large canvas
    function drawPixel(ctx, x, y, color) {
      const singlePixel = ctx.createImageData(1, 1);
      const d = singlePixel.data;

      d[0] = color;
      d[1] = color;
      d[2] = color;
      d[3] = 255;
      ctx.putImageData(singlePixel, x, y);
    }

    // Use the vertically oriented list to draw the image
    function listToImageVertical(list, canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let page = 0;
      let x = 0;
      let y = 7;

      // Move the list into the imageData object
      for (let i = 0; i < list.length; i++) {
        let binString = hexToBinary(list[i]);
        if (!binString.valid) {
          // eslint-disable-next-line no-console
           // 修复：不直接 return，而是跳过错误字节
          console.error('invalid hexToBinary: ', binString.s);
          continue;
        }
        binString = binString.result;
        if (binString.length === 4) {
          binString += '0000';
        }

        // Check if pixel is white or black
        for (let k = 0; k < binString.length; k++) {
          let color = 0;
          if (binString.charAt(k) === '1') {
            color = 255;
          }
          drawPixel(ctx, x, (page * 8) + y, color);
          y--;
          if (y < 0) {
            y = 7;
            x++;
            if (x >= settings.screenWidth) {
              x = 0;
              page++;
            }
          }
        }
      }
      // Save the canvas contents inside the img object. This way we can
      // reuse the img object when we want to scale / invert, etc.
      const img = new Image();
      img.src = canvas.toDataURL('image/png');
      images.first().img = img;
    }

    // Handle inserting an image by pasting code
    // eslint-disable-next-line no-unused-vars
    function handleTextInput(drawMode, isButtonClick = false, isDebounced = false) {
      
      // 如果是按钮点击，则更新默认模式
      if (isButtonClick) {
          lastDrawMode = drawMode;
      }
      
      const canvasContainer = document.getElementById('images-canvas-container');
      
      let canvas;
      if (images.length() === 0 || images.first().glyph !== 'pasted_data') {
          // 如果没有图像，或者第一个图像不是粘贴的，则创建一个新的 canvas 和 image 对象
          // 先移除旧的非粘贴图像预览
          if (images.length() > 0 && images.first().glyph !== 'pasted_data') {
              canvasContainer.innerHTML = '';
              images.remove(images.first());
          }
          
          canvas = document.createElement('canvas');
          if (canvasContainer.children.length) {
            canvasContainer.removeChild(canvasContainer.firstChild);
          }
          canvasContainer.appendChild(canvas);
          const image = new Image();
          // 使用特殊标识 'pasted_data'
          images.push(image, canvas, 'pasted_data'); 
      } else {
          // 如果已有粘贴图像，使用第一个图像对象
          const firstImage = images.first();
          canvas = firstImage.canvas;
      }

      canvas.width = parseInt(document.getElementById('text-input-width').value);
      canvas.height = parseInt(document.getElementById('text-input-height').value);
      settings.screenWidth = canvas.width;
      settings.screenHeight = canvas.height;


      let input = document.getElementById('byte-input').value;

      // -----------------------------------------------------------------------
      // 修复：更健壮的输入清洗逻辑 (解决头部空白/解析错误问题)
      // -----------------------------------------------------------------------
      
      // 1. 移除 C/C++ 块注释 /* ... */
      input = input.replace(/\/\*[\s\S]*?\*\//g, '');
      
      // 2. 移除单行注释 // ...
      input = input.replace(/\/\/.*$/gm, '');

      // 3. 移除 "0x" 或 "0X" 前缀
      input = input.replace(/0[xX]/g, '');

      // 4. 将所有 非十六进制字符 (0-9, a-f, A-F) 替换为逗号
      // 这会自动清除 const, static, uint8_t, 花括号 {}, 分号 ;, 变量名等所有非数据内容
      input = input.replace(/[^0-9a-fA-F]/g, ',');

      // 5. 分割并过滤空项
      const list = input.split(',').filter(s => s.trim().length > 0);

      // -----------------------------------------------------------------------

      // 使用上次设置的模式
      if (lastDrawMode === 'horizontal') {
        listToImageHorizontal(list, canvas);
      } else {
        listToImageVertical(list, canvas);
      }
      
      // 如果不是防抖触发，则手动调用一次生成
      if (!isDebounced) {
        manualGenerateCode();
      }
    }

    // eslint-disable-next-line no-unused-vars
    function allSameSize() {
      if (images.length() > 1) {
        const inputs = document.querySelectorAll('#image-size-settings input[type="number"]');
        // all images same size button
        const firstW = inputs[0].value;
        const firstH = inputs[1].value;

        for (let i = 2; i < inputs.length; i += 2) {
          inputs[i].value = firstW; // Width
          inputs[i+1].value = firstH; // Height
        }
        // 调用实时更新
        debounceUpdateAndGenerate();
      }
    }

    // Handle selecting an image with the file picker
    function handleImageSelection(evt) {
      const files = Array.from(evt.target.files);
      files.sort((a, b) => a.name > b.name);
      // error message
      const onlyImagesFileError = document.getElementById('only-images-file-error');

      onlyImagesFileError.style.display = 'none';

      // initial message
      const noFileSelected = document.querySelectorAll('.no-file-selected');
      if (files.length > 0) {
        noFileSelected.forEach((el) => {
          // eslint-disable-next-line no-param-reassign
          el.style.display = 'none';
        });
      } else {
        noFileSelected.forEach((el) => {
          // eslint-disable-next-line no-param-reassign
          el.style.display = 'block';
        });
      }
      
      // 清空粘贴的图像对象和预览，避免冲突
      if (images.length() > 0 && images.first().glyph === 'pasted_data') {
          const canvasContainer = document.getElementById('images-canvas-container');
          canvasContainer.innerHTML = '';
          images.remove(images.first());
      }


      for (let i = 0; files[i]; i++) {
        // Only process image files.
        if (!files[i].type.match('image.*')) {
          onlyImagesFileError.style.display = 'block';
          // eslint-disable-next-line no-continue
          continue;
        }

        const reader = new FileReader();

        reader.onload = (file) => {
          // eslint-disable-next-line no-param-reassign
          file.name = reader.name;
          // Render thumbnail.
          const img = new Image();

          img.onload = () => {
            const fileInputColumnEntry = document.createElement('div');
            fileInputColumnEntry.className = 'file-input-entry';

            const fileInputColumnEntryLabel = document.createElement('span');
            fileInputColumnEntryLabel.textContent = file.name;

            const fileInputColumnEntryRemoveButton = document.createElement('button');
            fileInputColumnEntryRemoveButton.className = 'remove-button';
            fileInputColumnEntryRemoveButton.innerHTML = '移除';

            const canvas = document.createElement('canvas');

            const imageEntry = document.createElement('li');
            imageEntry.setAttribute('data-img', file.name);

            const w = document.createElement('input');
            w.type = 'number';
            w.name = 'width';
            w.id = `screenWidth_${i}`; // Use a unique ID
            w.min = 0;
            w.className = 'size-input';
            w.value = img.width;
            settings.screenWidth = img.width;
            w.oninput = () => {
              canvas.width = w.value; // Use w.value directly
              // 调用实时更新
              debounceUpdateAndGenerate();
            };

            const h = document.createElement('input');
            h.type = 'number';
            h.name = 'height';
            h.id = `screenHeight_${i}`; // Use a unique ID
            h.min = 0;
            h.className = 'size-input';
            h.value = img.height;
            settings.screenHeight = img.height;
            h.oninput = () => {
              canvas.height = h.value; // Use h.value directly
              // 调用实时更新
              debounceUpdateAndGenerate();
            };

            const gil = document.createElement('span');
            gil.innerHTML = '字形:';
            gil.className = 'file-info';

            const gi = document.createElement('input');
            gi.type = 'text';
            gi.name = 'glyph';
            gi.className = 'glyph-input';
            gi.oninput = () => { // 更改为 oninput 实时更新
              const image = images.get(img);
              image.glyph = gi.value;
              // 调用实时更新
              debounceUpdateAndGenerate();
            };

            const fn = document.createElement('span');
            fn.className = 'file-info';
            fn.innerHTML = `${file.name} (文件分辨率: ${img.width} x ${img.height})`;
            // 移除原本的 <br /> 避免额外换行

            const rb = document.createElement('button');
            rb.className = 'remove-button';
            rb.innerHTML = '移除';

            const fileInputColumn = document.getElementById('file-input-column');
            const imageSizeSettings = document.getElementById('image-size-settings');
            const canvasContainer = document.getElementById('images-canvas-container');

            const removeButtonOnClick = () => {
              const image = images.get(img);
              canvasContainer.removeChild(image.canvas);
              images.remove(image);
              imageSizeSettings.removeChild(imageEntry);

              fileInputColumn.removeChild(fileInputColumnEntry);
              if (imageSizeSettings.children.length <= 1) {
                document.getElementById('all-same-size').style.display = 'none';
              }
              if (images.length() === 0) {
                noFileSelected.forEach((el) => {
                  // eslint-disable-next-line no-param-reassign
                  el.style.display = 'block';
                });
                document.getElementById('code-output').value = ''; // 清空输出
              }
              // 调用实时更新
              debounceUpdateAndGenerate();
            };

            rb.onclick = removeButtonOnClick;
            fileInputColumnEntryRemoveButton.onclick = removeButtonOnClick;

            fileInputColumnEntry.appendChild(fileInputColumnEntryLabel);
            fileInputColumnEntry.appendChild(fileInputColumnEntryRemoveButton);
            fileInputColumn.appendChild(fileInputColumnEntry);

            // 图像设置项布局调整：分辨率和字形在一行
            imageEntry.appendChild(fn); // 文件名和原始分辨率信息
            imageEntry.appendChild(document.createElement('br')); // 分隔行

            // 确保这些输入和字形信息在一行
            const inputRow = document.createElement('div');
            inputRow.className = 'input-row';

            inputRow.appendChild(w);
            inputRow.appendChild(document.createTextNode(' x '));
            inputRow.appendChild(h);
            inputRow.appendChild(document.createTextNode(' | ')); // 分隔符
            inputRow.appendChild(gil);
            inputRow.appendChild(gi);
            inputRow.appendChild(rb); // 移除按钮

            imageEntry.appendChild(inputRow);
            
            imageSizeSettings.appendChild(imageEntry);

            canvas.width = img.width;
            canvas.height = img.height;
            canvasContainer.appendChild(canvas);

            images.push(img, canvas, file.name.split('.')[0]);
            if (images.length() > 1) {
              document.getElementById('all-same-size').style.display = 'block';
            }
            
            // 首次加载图像后调用实时更新
            debounceUpdateAndGenerate(); 
          };
          img.src = file.target.result;
        };
        reader.name = files[i].name;
        reader.readAsDataURL(files[i]);
      }
    }

    function imageToString(image) {
      // extract raw image data
      const { ctx } = image;
      const { canvas } = image;

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const { data } = imageData;
      return settings.conversionFunction(data, canvas.width);
    }

    // Get the custom arduino output variable name, if any
    function getIdentifier() {
      const vn = document.getElementById('identifier');
      return vn && vn.value.length ? vn.value : identifier;
    }

    // Output the image string to the textfield
    // eslint-disable-next-line no-unused-vars
    function generateOutputString() {
      let outputString = '';
      let code = '';
      const copyButton = document.getElementById('copy-button');
      
      if (images.length() === 0) {
        document.getElementById('code-output').value = '请先选择或粘贴图像数据。';
        copyButton.disabled = true;
        return;
      }
      
      copyButton.disabled = false;


      switch (settings.outputFormat) {
        case 'arduino': {
          const varQuickArray = [];
          let bytesUsed = 0;
          // --
          images.each((image) => {
            code = imageToString(image);

            // Trim whitespace from end and remove trailing comma
            code = code.replace(/,\s*$/, '');

            code = `\t${code.split('\n').join('\n\t')}\n`;
            // const variableCount = images.length() > 1 ? count++ : '';
            const comment = `// '${image.glyph}', ${image.canvas.width}x${image.canvas.height}px\n`;
            bytesUsed += (code.split('\n').length - 1) * 16; // 16 bytes per line.

            const varname = getIdentifier() + image.glyph.replace(/[^a-zA-Z0-9]/g, '_');
            varQuickArray.push(varname);
            code = `${comment}const ${getImageType()} ${varname} [] PROGMEM = {\n${code}};\n`;
            outputString += code;
          });

          varQuickArray.sort();
          outputString += `\n// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = ${bytesUsed})\n`;
          outputString += `const int ${getIdentifier()}allArray_LEN = ${varQuickArray.length};\n`;
          outputString += `const ${getImageType()}* ${getIdentifier()}allArray[${varQuickArray.length}] = {\n\t${varQuickArray.join(',\n\t')}\n};\n`;
          break;
        }

        case 'arduino_single': {
          let comment = '';
          images.each((image) => {
            code = imageToString(image);
            code = `\t${code.split('\n').join('\n\t')}\n`;
            comment = `\t// '${image.glyph}, ${image.canvas.width}x${image.canvas.height}px\n`;
            outputString += comment + code;
          });

          outputString = outputString.replace(/,\s*$/, '');

          outputString = `const ${getImageType()} ${
            getIdentifier()
          } [] PROGMEM = {`
            + `\n${outputString}\n};`;
          break;
        }

        case 'adafruit_gfx': { // bitmap
          let comment = '';
          let useGlyphs = 0;
          images.each((image) => {
            code = imageToString(image);
            code = `\t${code.split('\n').join('\n\t')}\n`;
            comment = `\t// '${image.glyph}', ${image.canvas.width}x${image.canvas.height}px\n`;
            outputString += comment + code;
            if (image.glyph.length === 1) {
              useGlyphs++;
            }
          });

          outputString = outputString.replace(/,\s*$/, '');
          outputString = `const unsigned char ${
            getIdentifier()
          }Bitmap`
            + ' [] PROGMEM = {'
            + `\n${outputString}\n};\n\n`
            + `const GFXbitmapGlyph ${
              getIdentifier()
            }Glyphs [] PROGMEM = {\n`;

          let firstAschiiChar = parseInt(document.getElementById('first-ascii-char').value);
          const xAdvance = parseInt(document.getElementById('x-advance').value);
          let offset = 0;
          code = '';

          // GFXbitmapGlyph
          images.each((image) => {
            code += `\t{ ${
              offset}, ${
              image.canvas.width}, ${
              image.canvas.height}, ${
              xAdvance}, `
              + `'${images.length() === useGlyphs
                ? image.glyph
                : String.fromCharCode(firstAschiiChar++)}'`
              + ' }';
            if (image !== images.last()) {
              code += ',';
            }
            code += `// '${image.glyph}'\n`;
            offset += image.canvas.width;
          });
          code += '};\n';
          outputString += code;

          // GFXbitmapFont
          outputString += `\nconst GFXbitmapFont ${
            getIdentifier()
          }Font PROGMEM = {\n`
            + `\t(uint8_t *)${
              getIdentifier()}Bitmap,\n`
            + `\t(GFXbitmapGlyph *)${
              getIdentifier()
            }Glyphs,\n`
            + `\t${images.length()
            }\n};\n`;
          break;
        }
        default: { // plain
          images.each((image) => {
            code = imageToString(image);
            let comment = '';
            if (image.glyph) {
              comment = (`// '${image.glyph}', ${image.canvas.width}x${image.canvas.height}px\n`);
            }
            if (image.img !== images.first().img) {
              comment = `\n${comment}`;
            }
            code = comment + code;
            outputString += code;
          });
          // Trim whitespace from end and remove trailing comma
          outputString = outputString.replace(/,\s*$/g, '');
        }
      }

      document.getElementById('code-output').value = outputString;
    }

    // Copy the final output to the clipboard
    // eslint-disable-next-line no-unused-vars
    function copyOutput() {
      const copyButton = document.getElementById('copy-button');
      navigator.clipboard.writeText(document.getElementById('code-output').value)
        .then(() => {
          // 更改按钮样式和文本
          copyButton.textContent = '已复制';
          copyButton.classList.add('copy-success');
          
          // 2秒后恢复
          setTimeout(() => {
            copyButton.textContent = '复制输出';
            copyButton.classList.remove('copy-success');
          }, 2000);
        })
        .catch(err => {
          console.error('复制失败: ', err);
          // 复制失败时提供手动复制的提示
          alert('复制失败，请手动选择并复制。'); 
        });
    }

    // 下载为二进制文件 (.bin)
    // eslint-disable-next-line no-unused-vars
    function downloadBinFile() {
      if (images.length() === 0) {
        alert('请先生成代码。');
        return;
      }
      let raw = [];
      images.each((image) => {
        const data = imageToString(image)
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean)
          .map((byte) => parseInt(byte, 16));
        raw = raw.concat(data);
      });
      const data = new Uint8Array(raw);
      const a = document.createElement('a');
      a.style = 'display: none';
      document.body.appendChild(a);
      const blob = new Blob([data], { type: 'octet/stream' });
      const url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = `${getIdentifier()}.bin`;
      a.click();
      window.URL.revokeObjectURL(url);
    }

    // 新增：下载代码文件 (.c)
    // eslint-disable-next-line no-unused-vars
    function downloadCodeFile() {
      const outputContent = document.getElementById('code-output').value;
      if (!outputContent || outputContent === '请先选择或粘贴图像数据。') {
        alert('请先生成代码。');
        return;
      }
      
      const blob = new Blob([outputContent], { type: 'text/plain' });
      const a = document.createElement('a');
      a.style = 'display: none';
      document.body.appendChild(a);
      const url = window.URL.createObjectURL(blob);
      a.href = url;
      a.download = 'p2c.c'; // 指定下载文件名为 p2c.c
      a.click();
      window.URL.revokeObjectURL(url);
    }


    // eslint-disable-next-line no-unused-vars
    function updateDrawMode(elm) {
      const conversionFunction = ConversionFunctions[elm.value];
      if (conversionFunction) {
        settings.conversionFunction = conversionFunction;
      }
      // 调用实时更新
      debounceUpdateAndGenerate();
    }

    // Updates Arduino code check-box
    // eslint-disable-next-line no-unused-vars
    function updateOutputFormat(elm) {
      let caption = document.getElementById('format-caption-container');
      const adafruitGfx = document.getElementById('adafruit-gfx-settings');
      const arduino = document.getElementById('arduino-identifier');
      const removeZeroesCommasContainer = document.getElementById('remove-zeroes-commas-container');
      document.getElementById('code-output').value = '';

      for (let i = 0; i < caption.children.length; i++) {
        caption.children[i].style.display = 'none';
      }
      caption = document.querySelector(`div[data-caption='${elm.value}']`);
      if (caption) caption.style.display = 'block';

      if (elm.value !== 'plain') {
        arduino.style.display = 'block';
        removeZeroesCommasContainer.style.display = 'none';
        settings.removeZeroesCommas = false;
        document.getElementById('removeZeroesCommas').checked = false;
      } else {
        arduino.style.display = 'none';
        removeZeroesCommasContainer.style.display = 'table-row';
      }
      if (elm.value === 'adafruit_gfx') {
        adafruitGfx.style.display = 'block';
      } else {
        adafruitGfx.style.display = 'none';
      }

      settings.outputFormat = elm.value;
      // 调用实时更新
      debounceUpdateAndGenerate();
    }

    // Easy way to update settings controlled by a radiobutton
    // eslint-disable-next-line no-unused-vars
    function updateRadio(fieldName) {
      const radioGroup = document.getElementsByName(fieldName);
      for (let i = 0; i < radioGroup.length; i++) {
        if (radioGroup[i].checked) {
          settings[fieldName] = radioGroup[i].value;
        }
      }
      // 调用实时更新
      debounceUpdateAndGenerate();
    }

    window.onload = () => {
      document.getElementById('copy-button').disabled = true;

      // Add events to the file input button
      const fileInput = document.getElementById('file-input');
      fileInput.addEventListener('click', () => { fileInput.value = null; }, false);
      fileInput.addEventListener('change', handleImageSelection, false);
      document.getElementById('outputFormat').value = 'arduino';
      updateOutputFormat(document.getElementById('outputFormat')); // 调用一次初始化设置并触发第一次生成
    };
  </script>
  
  <script>
        // Disable right-click menu and F12/Ctrl+Shift+I/Ctrl+U
        document.addEventListener('contextmenu',function(e){e.preventDefault();});
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && e.keyCode == 73) || (e.ctrlKey && e.keyCode == 85)) {
                return false;
            }
            if (e.keyCode == 116) { // Disable F5 (refresh)
                e.preventDefault();
            }
        };
</script>
</body>
</html>