<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QMK灯光控制台</title>
    <style>
        /* 浅色系主题变量 */
        :root {
            --bg-color: #f4f4f4;
            --panel-bg: #ffffff;
            --text-color: #333333;
            --accent-color: #1e88e5;
            --highlight-color: #ffc107;
            --border-color: #ccc;

            --color-h: #d9534f;
            --color-s: #5cb85c;
            --color-v: #f0ad4e;
            --color-spd: #1e88e5;
            
            --color-r: #d9534f;
            --color-g: #5cb85c;
            --color-b: #1e88e5;
            
            --progress-color-hue: #ff0000; 
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            user-select: none;
        }

        h1, h2, h3 { margin: 0 0 10px 0; }

        .container {
            background-color: var(--panel-bg);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 1000px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }

        .header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        button:hover { background-color: #0b73c2; }
        button:active { transform: scale(0.98); }
        button:disabled { background-color: #aaa; cursor: not-allowed; }
        button.danger { background-color: #d9534f; }
        button.danger:hover { background-color: #c9302c; }
        
        .status { font-size: 0.9em; color: #888; margin-left: 10px; }
        .status.connected { color: #5cb85c; font-weight: bold; }

        /* 输入框样式调整：改为 text 类型以支持 Hex 显示 */
        input[type="text"], input[type="number"] {
            background: #f0f0f0;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 5px;
            border-radius: 4px;
            width: 50px;
            text-align: center;
            transition: border-color 0.2s;
            flex-shrink: 0;
            font-family: monospace; /* 等宽字体方便看 Hex */
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--accent-color);
            outline: none;
        }
        
        /* LED 网格区域 */
        .led-section { margin-bottom: 10px; position: relative; }
        
        /* 第一行：灯珠总数与进制切换 */
        .led-controls-row1 { 
            margin-bottom: 10px; 
            display: flex; 
            align-items: center; 
            gap: 15px; 
            flex-wrap: wrap; 
            padding-bottom: 10px;
            border-bottom: 1px dashed #eee;
        }
        
        /* 第二行：模式选择 */
        .mode-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 8px;
        }

        .mode-btn {
            background-color: #e0e0e0;
            color: #333;
            padding: 6px 12px;
            font-size: 0.9em;
        }
        .mode-btn:hover { background-color: #d0d0d0; }
        .mode-btn.active {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* 指示灯参数区域 (仅在非全灯模式显示) */
        .indicator-params {
            display: none; /* 默认隐藏 */
            align-items: center;
            gap: 10px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 2px solid #ddd;
        }
        .indicator-params.visible { display: flex; }

        /* 全灯模式下的操作按钮 */
        .all-led-actions {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }
        
        .led-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(35px, 1fr));
            gap: 6px;
            padding: 10px;
            background: #e8e8e8;
            border-radius: 8px;
            max-height: 280px;
            overflow-y: auto;
            border: 1px solid #ccc;
            position: relative;
        }
        .led-grid.hidden { display: none; }

        .led-item {
            width: 35px;
            height: 35px;
            background-color: #ddd;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            cursor: pointer;
            transition: all 0.1s;
            border: 2px solid transparent;
        }

        /* 选中框样式 */
        .selection-marquee {
            position: fixed;
            background: rgba(30, 136, 229, 0.3);
            border: 1px dashed #1e88e5; 
            display: none;
            pointer-events: none;
            z-index: 9999;
            border-radius: 4px;
        }

        .led-item.active {
            box-shadow: 0 0 10px var(--highlight-color), 0 0 4px rgba(0,0,0,0.2);
            font-weight: bold;
            border-color: var(--text-color);
        }
        
        .led-item.preview-select {
            filter: brightness(1.2);
            transform: scale(1.1);
        }

        /* 效果配置区 */
        .effect-config {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            align-items: flex-start; 
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .color-wheel-section { flex-shrink: 0; }
        .control-and-preview-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-grow: 1;
            min-width: 300px;
        }
        
        #colorWheelCanvas {
            border-radius: 50%;
            background-color: #ffffff;
            cursor: crosshair;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }
        
        .slider-row {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }
        
        .slider-row label { width: 50px; font-size: 0.9em; flex-shrink: 0; }
        
        .rgb-controls-row {
            display: flex;
            justify-content: space-between;
            gap: 15px; 
            width: 100%;
            padding-top: 5px;
            border-top: 1px dashed var(--border-color);
        }

        .rgb-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1;
            flex-basis: 0;
            gap: 5px;
            min-width: 80px; 
            text-align: center;
        }

        .rgb-item label { width: 100%; font-weight: 600; margin-bottom: 2px; font-size: 0.9em; }
        
        .range-number-row {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }
        .range-number-row input[type="range"] { width: 100%; }

        input[type="range"] { 
            flex-grow: 1;
            height: 8px; 
            border-radius: 4px; 
            background: #ccc;
            cursor: grab; 
            --track-color: #ccc;
            --progress-color: var(--accent-color);
            --value: 0;
            background: linear-gradient(to right, 
                var(--progress-color) 0%, 
                var(--progress-color) var(--value), 
                var(--track-color) var(--value), 
                var(--track-color) 100%
            );
        }
        
        #hueRange { 
            background: linear-gradient(to right, 
                #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, 
                #0000ff 67%, #ff00ff 83%, #ff0000 100%
            ) !important;
            border: 1px solid var(--border-color);
        }
        #satRange { --progress-color: var(--color-s); }
        #valRange { --progress-color: var(--color-v); }
        #spdRange { --progress-color: var(--color-spd); }
        #redRange { --progress-color: var(--color-r); }
        #greenRange { --progress-color: var(--color-g); }
        #blueRange { --progress-color: var(--color-b); }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        input[type="range"]:not(#hueRange)::-webkit-slider-thumb {
             background: var(--progress-color); border: none;
        }
        #hueRange::-webkit-slider-thumb {
            background: var(--progress-color-hue); 
            border: 2px solid #fff;
        }

        .preview-bar-row {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
            margin-top: 5px;
        }

        .preview-bar {
            height: 20px; 
            border-radius: 6px; 
            border: 1px solid #999;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
            flex-grow: 1;
            opacity: 1 !important;
        }

        .config-action-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 10px;
            margin-top: 5px;
            border-top: 1px solid var(--border-color); 
        }
        
        .sync-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px; width: 16px;
            left: 3px; bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-color); }
        input:focus + .slider { box-shadow: 0 0 1px var(--accent-color); }
        input:checked + .slider:before { transform: translateX(18px); }
        
        .sync-label { font-size: 0.9em; color: #666; user-select: none; }

        /* 列表区域 */
        .config-list-container {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }

        .config-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .config-row {
            grid-template-columns: 80px repeat(3, 1fr) repeat(3, 1fr) 1fr 100px 120px; 
            display: grid;
            align-items: center;
            gap: 10px;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 6px;
            border-left: 6px solid transparent;
            transition: background 0.1s, border-left 0.1s;
        }
        
        .config-color-display {
            text-align: center;
            padding: 5px 0;
            border-radius: 4px;
            font-weight: bold;
            background-color: #f0f0f0;
            color: var(--text-color);
        }
        
        .config-row:hover { background: #e9e9e9; cursor: pointer; }
        .config-row.selected { border-left-color: var(--highlight-color); background: #e0e0e0; }
        .config-row span { font-size: 0.85em; color: var(--text-color); }
        .config-row-controls { display: flex; gap: 5px; justify-content: flex-end; }
        .btn-icon { padding: 5px 12px; font-size: 1.2em; line-height: 1; }
        .config-row input { width: 100%; box-sizing: border-box; }

        .footer-controls {
            margin-top: 20px;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }

        /* 格式切换开关样式 */
        .format-switch-container {
            display: flex;
            align-items: center;
            background: #e0e0e0;
            border-radius: 4px;
            padding: 2px;
            font-size: 0.8em;
            cursor: pointer;
        }
        .format-option {
            padding: 4px 8px;
            border-radius: 3px;
        }
        .format-option.active {
            background: #fff;
            color: var(--accent-color);
            font-weight: bold;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="selectionMarquee" class="selection-marquee"></div>

<div class="container">
    <div class="header-controls">
        <h2>QMK 灯光配置工具</h2>
        <div>
            <span id="connectionStatus" class="status">未连接</span>
            <button id="connectBtn">连接键盘</button>
        </div>
    </div>

    <div class="led-section">
        <div class="led-controls-row1">
            <label>灯珠总数 (Max 208):</label>
            <input type="text" id="ledTotalInput" value="8" data-max="208">
            
            <div class="format-switch-container" id="formatSwitch" title="切换数值显示格式">
                <div class="format-option active" data-mode="dec">十进制</div>
                <div class="format-option" data-mode="hex">十六进制</div>
            </div>
        </div>

        <div class="mode-controls-row">
            <button class="mode-btn active" data-mode="all">全灯 (All)</button>
            <button class="mode-btn" data-mode="caps">Caps Lock</button>
            <button class="mode-btn" data-mode="num">Num Lock</button>
            <button class="mode-btn" data-mode="scr">Scroll Lock</button>
            <button class="mode-btn" data-mode="layer">Layer</button>

            <div id="indicatorParams" class="indicator-params">
                <div id="layerParamGroup" style="display:none; align-items:center; gap:5px;">
                    <label>层:</label>
                    <input type="text" id="layerIndexInput" value="0" title="层索引 (0-Based)">
                </div>

                <label>起始:</label>
                <input type="text" id="indStartInput" value="0" title="起始灯珠索引">
                <label>覆盖:</label>
                <input type="text" id="indCountInput" value="1" title="覆盖灯珠数量">
                <button id="saveIndicatorBtn" style="background: #28a745; font-size: 0.9em; padding: 5px 10px;">保存配置</button>
            </div>

            <div id="allLedActions" class="all-led-actions">
                <span style="font-size: 0.8em; color: #888; display:flex; align-items:center;">(拖拽框选/点击切换)</span>
                <button id="selectAllBtn" style="font-size:0.8em; padding:6px 12px; background:#4CAF50;">全选</button>
                <button id="clearSelectionBtn" style="font-size:0.8em; padding:6px 12px; background:#666;">清空</button>
            </div>
        </div>

        <div id="ledGrid" class="led-grid"></div>
    </div>

    <div class="effect-config">
        
        <div class="color-wheel-section">
            <canvas id="colorWheelCanvas" width="250" height="250"></canvas>
        </div>

        <div class="control-and-preview-area">
            
            <div class="slider-group">
                <div class="slider-row">
                    <label>色相 (H)</label>
                    <input type="range" id="hueRange" min="0" max="255" value="0">
                    <input type="text" id="hueInput" value="0">
                </div>
                <div class="slider-row">
                    <label>饱和 (S)</label>
                    <input type="range" id="satRange" min="0" max="255" value="255">
                    <input type="text" id="satInput" value="255">
                </div>
                <div class="slider-row">
                    <label>亮度 (V)</label>
                    <input type="range" id="valRange" min="0" max="255" value="255">
                    <input type="text" id="valInput" value="255">
                </div>
                <div class="slider-row">
                    <label>速度</label>
                    <input type="range" id="spdRange" min="0" max="255" value="128">
                    <input type="text" id="spdInput" value="128">
                </div>
            </div>

            <div class="preview-bar-row">
                <label style="font-size: 0.9em; flex-shrink: 0;">预览</label>
                <div id="colorPreview" class="preview-bar" title="灯光预览"></div>
            </div>

            <div class="slider-group">
                <div id="rgbControlsRow" class="rgb-controls-row"> 
                    <div class="rgb-item">
                        <label>红 (R)</label>
                        <div class="range-number-row">
                            <input type="range" id="redRange" min="0" max="255" value="0">
                            <input type="text" id="redInput" value="0">
                        </div>
                    </div>
                    <div class="rgb-item">
                        <label>绿 (G)</label>
                        <div class="range-number-row">
                            <input type="range" id="greenRange" min="0" max="255" value="0">
                            <input type="text" id="greenInput" value="0">
                        </div>
                    </div>
                    <div class="rgb-item">
                        <label>蓝 (B)</label>
                        <div class="range-number-row">
                            <input type="range" id="blueRange" min="0" max="255" value="0">
                            <input type="text" id="blueInput" value="0">
                        </div>
                    </div>
                </div>
            </div>
            <div class="config-action-row">
                <span id="currentDrawDisplay" style="font-size: 1.1em; font-weight: bold; color: var(--accent-color);">
                    预计电流: 0.0 mA
                </span>

                <div class="sync-control">
                    <span class="sync-label">实时同步</span>
                    <label class="switch">
                        <input type="checkbox" id="realtimeSyncToggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <button id="addConfigBtn" class="btn-icon" title="添加到列表">+ 添加</button>
            </div>
        </div>
    </div>

    <div class="config-list-container">
        <h3>灯光配置列表 (全灯模式)</h3>
        <div class="config-row" style="background: transparent; cursor: default; font-weight: bold; color: var(--accent-color);">
            <span style="text-align: center;">灯珠数量</span>
            <span style="text-align: center;">色相(H)</span>
            <span style="text-align: center;">饱和(S)</span>
            <span style="text-align: center;">亮度(V)</span>
            <span style="text-align: center;">红(R)</span> 
            <span style="text-align: center;">绿(G)</span>
            <span style="text-align: center;">蓝(B)</span>
            <span style="text-align: center;">速度</span>
            <span style="text-align: right;">预计电流</span>
            <span style="text-align: right;">操作</span>
        </div>
        <div id="configList" class="config-list"></div>
    </div>

    <div class="footer-controls">
        <button id="sendAllBtn" style="background-color: #3f72af;">全部发送 (列表)</button>
        <button id="closeLightBtn" class="danger">关闭灯光</button>
    </div>
</div>

<script>
/**
 * 全局状态变量
 */
let device = null;
let disconnectListener = null;
let ledTotal = 8;
const PEAK_CURRENT_PER_CHANNEL = 20; 
let selectedLeds = new Set(); 
let currentConfigId = null; 

// 显示模式: 'dec' 或 'hex'
let displayMode = 'dec';
// 当前操作模式: 'all', 'caps', 'num', 'scr', 'layer'
let currentMode = 'all';

// 设备读取到的最大层数
let maxLayers = 0; 

// 默认配置
let currentSettings = {
    h: 0, s: 255, v: 255, spd: 128,
    r: 255, g: 0, b: 0
};

// 指示灯单独的配置存储 (Start, Count, Layer)
let indicatorSettings = {
    caps:  { start: 0, count: 1 },
    num:   { start: 0, count: 1 },
    scr:   { start: 0, count: 1 },
    layer: { start: 0, count: 1, layerIdx: 0 }
};

let configList = [];
let vChanged = false; 
let isDraggingWheel = false; 
let isRealTimeSyncSending = false;
let pendingRealTimeSync = false;
let isSelecting = false;
let startX = 0;
let startY = 0;
let isClick = true; 
let initialTargetEl = null;

document.addEventListener('DOMContentLoaded', () => {
    initLedGrid();
    setupEventListeners();
    setupSyncInputs();
    setupColorWheel(); 
    setupModeControls(); 
    setupFormatSwitch(); 
    
    updateColorSettings('h', currentSettings.h); 
    syncAllInputsFromSettings(); 
    updateConnectionStatus(false); 
});

// --- 数值/格式处理辅助函数 ---

function formatValue(val) {
    if (displayMode === 'hex') {
        return "0x" + parseInt(val).toString(16).toUpperCase();
    }
    return val.toString();
}

function parseValue(valStr) {
    if (!valStr) return 0;
    valStr = valStr.toString().trim();
    if (valStr.toLowerCase().startsWith('0x')) {
        return parseInt(valStr, 16);
    }
    if (/[a-f]/i.test(valStr)) return parseInt(valStr, 16);
    return parseInt(valStr); // 默认 10 进制
}

// 刷新所有相关输入框的显示格式
function updateAllInputFormats() {
    // 1. 灯珠总数
    const ledTotalInput = document.getElementById('ledTotalInput');
    ledTotalInput.value = formatValue(ledTotal);

    // 2. 指示灯输入框
    const startInput = document.getElementById('indStartInput');
    const countInput = document.getElementById('indCountInput');
    const layerInput = document.getElementById('layerIndexInput');

    if (currentMode !== 'all') {
        const conf = indicatorSettings[currentMode];
        startInput.value = formatValue(conf.start);
        countInput.value = formatValue(conf.count);
        if (currentMode === 'layer') {
            layerInput.value = formatValue(conf.layerIdx);
        }
    }

    // 3. 颜色/速度输入框
    const inputs = ['hue', 'sat', 'val', 'spd', 'red', 'green', 'blue'];
    inputs.forEach(prefix => {
        const el = document.getElementById(`${prefix}Input`);
        const range = document.getElementById(`${prefix}Range`);
        if (el && range) {
            el.value = formatValue(range.value);
        }
    });
}

// --- 模式切换与UI逻辑 ---

function setupFormatSwitch() {
    const container = document.getElementById('formatSwitch');
    const options = container.querySelectorAll('.format-option');
    
    options.forEach(opt => {
        opt.addEventListener('click', () => {
            options.forEach(o => o.classList.remove('active'));
            opt.classList.add('active');
            displayMode = opt.dataset.mode;
            updateAllInputFormats();
        });
    });
}

function setupModeControls() {
    const btns = document.querySelectorAll('.mode-btn');
    const indicatorParams = document.getElementById('indicatorParams');
    const allLedActions = document.getElementById('allLedActions');
    const ledGrid = document.getElementById('ledGrid');
    const layerGroup = document.getElementById('layerParamGroup');
    
    const startInput = document.getElementById('indStartInput');
    const countInput = document.getElementById('indCountInput');
    const layerInput = document.getElementById('layerIndexInput');
    const saveBtn = document.getElementById('saveIndicatorBtn');

    btns.forEach(btn => {
        btn.addEventListener('click', () => {
            btns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            const mode = btn.dataset.mode;
            currentMode = mode;

            if (mode === 'all') {
                indicatorParams.classList.remove('visible');
                allLedActions.style.display = 'flex';
                ledGrid.classList.remove('hidden');
                document.querySelector('.config-list-container').style.opacity = '1';
                document.querySelector('.config-list-container').style.pointerEvents = 'auto';
            } else {
                indicatorParams.classList.add('visible');
                allLedActions.style.display = 'none';
                ledGrid.classList.add('hidden');
                document.querySelector('.config-list-container').style.opacity = '0.5';
                document.querySelector('.config-list-container').style.pointerEvents = 'none';

                // Layer 输入框可见性
                if (mode === 'layer') {
                    layerGroup.style.display = 'flex';
                    layerInput.value = formatValue(indicatorSettings.layer.layerIdx);
                } else {
                    layerGroup.style.display = 'none';
                }

                startInput.value = formatValue(indicatorSettings[mode].start);
                countInput.value = formatValue(indicatorSettings[mode].count);
            }
            triggerRealTimeSync();
        });
    });

    const handleIndInputChange = () => {
        if (currentMode === 'all') return;
        
        let sVal = parseValue(startInput.value);
        let cVal = parseValue(countInput.value);
        
        if (isNaN(sVal) || sVal < 0) sVal = 0;
        if (isNaN(cVal) || cVal < 0) cVal = 1;

        indicatorSettings[currentMode].start = sVal;
        indicatorSettings[currentMode].count = cVal;
        
        triggerRealTimeSync(); 
    };

    // Layer 专用输入处理
    const handleLayerInputChange = () => {
        if (currentMode !== 'layer') return;
        let lVal = parseValue(layerInput.value);
        
        if (isNaN(lVal) || lVal < 0) lVal = 0;
        
        // 限制层数不超过获取到的最大值
        if (maxLayers > 0 && lVal >= maxLayers) {
            lVal = maxLayers - 1;
            showCustomAlert("层数限制", `当前设备最大层数为 ${maxLayers} (索引 0-${maxLayers-1})`);
        }

        indicatorSettings.layer.layerIdx = lVal;
        triggerRealTimeSync();
    };

    startInput.addEventListener('change', () => { handleIndInputChange(); startInput.value = formatValue(indicatorSettings[currentMode].start); });
    countInput.addEventListener('change', () => { handleIndInputChange(); countInput.value = formatValue(indicatorSettings[currentMode].count); });
    
    layerInput.addEventListener('change', () => { 
        handleLayerInputChange(); 
        layerInput.value = formatValue(indicatorSettings.layer.layerIdx); 
    });

    saveBtn.addEventListener('click', () => {
        if (currentMode === 'all') return;
        sendIndicatorCommand(true); // true = save
    });
}

// --- 核心逻辑 ---

function hsvToRgb(h, s, v) {
    h /= 255; s /= 255; v /= 255;
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}

function rgbToHsv(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    const delta = max - min;
    let h, s, v = max;
    if (delta === 0) { h = 0; s = 0; } else {
        s = delta / max;
        if (max === r) h = (g - b) / delta + (g < b ? 6 : 0);
        else if (max === g) h = (b - r) / delta + 2;
        else if (max === b) h = (r - g) / delta + 4;
        h /= 6; h *= 255;
    }
    return { h: Math.round(h), s: Math.round(s * 255), v: Math.round(v * 255) };
}

function updateColorSettings(sourceKey, value) {
    const clampedVal = Math.min(255, Math.max(0, value));
    currentSettings[sourceKey] = clampedVal;
    let newHsv, newRgb;
    if (['r', 'g', 'b'].includes(sourceKey)) {
        newHsv = rgbToHsv(currentSettings.r, currentSettings.g, currentSettings.b);
        currentSettings.h = newHsv.h;
        currentSettings.s = newHsv.s;
        currentSettings.v = newHsv.v;
        vChanged = true;
    } else if (['h', 's', 'v'].includes(sourceKey)) {
        newRgb = hsvToRgb(currentSettings.h, currentSettings.s, currentSettings.v);
        currentSettings.r = newRgb.r;
        currentSettings.g = newRgb.g;
        currentSettings.b = newRgb.b;
        if (sourceKey === 'v') vChanged = true; 
    }
}

function calculateCurrent(numLeds, h, s, v) {
    if (numLeds === 0) return '0.0';
    const { r, g, b } = hsvToRgb(h, s, v);
    const currentPerLed = ((r/255) + (g/255) + (b/255)) * PEAK_CURRENT_PER_CHANNEL;
    return (numLeds * currentPerLed).toFixed(1); 
}

function updateRangeProgress(rangeEl, value) {
    const percentage = (value / 255) * 100 + '%';
    rangeEl.style.setProperty('--value', percentage);
}

function updateHueProgress(rangeEl, hValue) {
    const { r, g, b } = hsvToRgb(hValue, 255, 255); 
    rangeEl.style.setProperty('--progress-color-hue', `rgb(${r}, ${g}, ${b})`);
}

function updateLedVisuals(ledEl, index) {
    if (selectedLeds.has(index)) {
        ledEl.classList.add('active');
        const { r, g, b } = hsvToRgb(currentSettings.h, currentSettings.s, currentSettings.v);
        ledEl.style.backgroundColor = `rgb(${r}, ${g}, ${b})`; 
        ledEl.style.color = currentSettings.v < 100 ? '#fff' : '#333'; 
    } else {
        ledEl.classList.remove('active');
        ledEl.style.backgroundColor = '#ddd';
        ledEl.style.removeProperty('color');
    }
}

function updateAllActiveLedColors() {
    const ledItems = document.querySelectorAll('.led-item');
    ledItems.forEach(ledEl => {
        updateLedVisuals(ledEl, parseInt(ledEl.dataset.index)); 
    });
}

function updateColorPreview() {
    const { r, g, b } = currentSettings;
    const box = document.getElementById('colorPreview');
    box.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
    box.style.borderColor = (r+g+b)/3 > 200 ? '#333' : '#aaa'; 
}

function updateCurrentDrawDisplay() {
    let numLeds = 0;
    if (currentMode === 'all') {
        numLeds = selectedLeds.size;
    } else {
        numLeds = indicatorSettings[currentMode].count;
    }
    const current = calculateCurrent(numLeds, currentSettings.h, currentSettings.s, currentSettings.v);
    document.getElementById('currentDrawDisplay').textContent = `预计电流: ${current} mA`;
}

// --- 数据发送与同步 ---

/**
 * 发送指示灯数据 (Caps/Num/Scr/Layer)
 * @param {boolean} isSave 是否是保存操作 (false=预览)
 */
async function sendIndicatorCommand(isSave) {
    if (!device || !device.opened) return;
    if (currentMode === 'all') return;

    const config = indicatorSettings[currentMode];
    let cmd = 0;

    // 确定命令字 (根据您的要求)
    switch(currentMode) {
        case 'caps':  cmd = isSave ? 0xC1 : 0xC0; break;
        case 'num':   cmd = isSave ? 0xC3 : 0xC2; break;
        case 'scr':   cmd = isSave ? 0xC5 : 0xC4; break;
        case 'layer': cmd = isSave ? 0xD1 : 0xD0; break; // 假设 Layer 保存是 D1
    }

    const data = new Uint8Array(32);
    data[0] = 0xAB;
    data[1] = cmd;

    if (isSave) {
        // 保存指令：仅发送命令头，后续全0补齐 (根据要求 0xC1 后面00补齐)
        // 数组初始化时默认就是0，所以这里不需要填数据，直接发送
        // 0xAB [CMD] 00 00 ...
    } else {
        // 预览指令：发送数据，向后移位
        // 结构: AB [CMD] [Byte2] [Start] [Count] [H] [S] [V] ...
        
        if (currentMode === 'layer') {
            data[2] = config.layerIdx; // Layer 模式下 data[2] 是层索引
        } else {
            data[2] = 0x00; // 其他模式下 data[2] 是 00 (向后移位造成的填充)
        }

        data[3] = config.start; 
        data[4] = config.count;
        data[5] = currentSettings.h;
        data[6] = currentSettings.s;
        data[7] = currentSettings.v;
    }

    try {
        await device.sendReport(0, data);
        if (isSave) {
            showCustomAlert("保存成功", `${currentMode.toUpperCase()} 指示灯配置已发送保存指令！`, false);
            setTimeout(() => document.getElementById('customAlert').style.display='none', 1000);
        }
    } catch (e) {
        console.error(e);
    }
}


async function triggerRealTimeSync() {
    if (currentMode !== 'all') {
        if (device && device.opened) {
            sendIndicatorCommand(false); // 发送预览
        }
        return;
    }

    // 全灯模式逻辑
    const syncCheckbox = document.getElementById('realtimeSyncToggle');
    if (!syncCheckbox || !syncCheckbox.checked || !device || !device.opened || !selectedLeds.size) return;

    if (isRealTimeSyncSending) {
        pendingRealTimeSync = true;
        return;
    }
    isRealTimeSyncSending = true;

    const mask = generateBitmask(selectedLeds);
    await sendDataToDevice(0xB0, currentSettings.h, currentSettings.s, currentSettings.v, currentSettings.spd, mask);

    isRealTimeSyncSending = false;
    if (pendingRealTimeSync) {
        pendingRealTimeSync = false;
        triggerRealTimeSync();
    }
}

function syncLightweightUIFromSettings() {
    const hsvSpdKeys = ['h', 's', 'v', 'spd'];
    const hsvSpdPrefix = ['hue', 'sat', 'val', 'spd'];

    hsvSpdPrefix.forEach((prefix, idx) => {
        const key = hsvSpdKeys[idx];
        const val = currentSettings[key];
        const range = document.getElementById(`${prefix}Range`);
        const textInput = document.getElementById(`${prefix}Input`);

        range.value = val;
        updateRangeProgress(range, val);
        textInput.value = formatValue(val);
        
        if (prefix === 'hue') updateHueProgress(range, val);
    });

    const rgbKeys = ['r', 'g', 'b'];
    const rgbPrefix = ['red', 'green', 'blue'];
    rgbPrefix.forEach((prefix, idx) => {
        const key = rgbKeys[idx];
        const val = currentSettings[key];
        const range = document.getElementById(`${prefix}Range`);
        const textInput = document.getElementById(`${prefix}Input`);
        
        if (range) {
            range.value = val;
            updateRangeProgress(range, val);
        }
        if (textInput) textInput.value = formatValue(val);
    });

    updateColorPreview();
    if (!isDraggingWheel) updateWheelIndicator(currentSettings.h, currentSettings.s);
    if (currentMode === 'all') updateAllActiveLedColors();
    updateCurrentDrawDisplay();
    triggerRealTimeSync();
}

function syncHeavyUIFromSettings() {
    updateWheelIndicator(currentSettings.h, currentSettings.s);
    if (currentMode === 'all') autoSyncSelectedConfig(true);
}

function syncAllInputsFromSettings() {
    vChanged = true; 
    const allKeys = ['h', 's', 'v', 'spd', 'r', 'g', 'b'];
    allKeys.forEach((key) => {
        currentSettings[key] = Math.min(255, Math.max(0, currentSettings[key]));
    });
    updateColorSettings('h', currentSettings.h); 
    syncLightweightUIFromSettings();
    syncHeavyUIFromSettings();
}

// --- WebHID ---

// 处理设备发来的数据
function handleInputReport(e) {
    const data = e.data;
    // 假设第一个字节是 ReportID 或 Header，如果协议不包含ReportID则直接从0开始
    // 根据要求: "data[1]是D0表示层指示灯，data[2]表示设置是的那一层的..."
    // 但此处是处理 "连接发送0x11然后接收到的数据"
    
    // 如果收到的数据长度足够
    if (data.byteLength > 1) {
        // 读取第二个字节 (Index 1) 作为最大层数
        const receivedVal = data.getUint8(1);
        
        // 简单的判断：如果收到的值看起来合理 (比如 < 32)，则认为是层数
        if (receivedVal > 0 && receivedVal < 32) {
            maxLayers = receivedVal;
            console.log("Device Max Layers:", maxLayers);
            // 更新 UI 提示或重置输入框
            const layerInput = document.getElementById('layerIndexInput');
            if (layerInput) {
                layerInput.title = `层索引 (0-${maxLayers-1})`;
            }
        }
    }
}

function updateConnectionStatus(connected) {
    const statusEl = document.getElementById('connectionStatus');
    const btn = document.getElementById('connectBtn');
    if (connected) {
        statusEl.textContent = "已连接: " + device.productName;
        statusEl.className = "status connected";
        btn.textContent = "已连接 (重连)";
        btn.disabled = false;
    } else {
        statusEl.textContent = "未连接";
        statusEl.className = "status";
        btn.textContent = "连接键盘";
        btn.disabled = false;
        if (device && !connected) device = null;
    }
}

async function connectDevice() {
    try {
        const filters = [{ usagePage: 0xFF60 }];
        const devices = await navigator.hid.requestDevice({ filters });
        if (devices.length > 0) {
            const newDevice = devices[0];
            if (device) {
                if (disconnectListener) navigator.hid.removeEventListener('disconnect', disconnectListener);
                if (device.opened) {
                    // 移除旧的 report 监听器
                    device.removeEventListener('inputreport', handleInputReport);
                    await device.close();
                }
            }
            device = newDevice;
            if (!device.opened) await device.open();
            
            // 监听数据返回
            device.addEventListener('inputreport', handleInputReport);

            disconnectListener = (e) => {
                if (e.device === device) {
                    navigator.hid.removeEventListener('disconnect', disconnectListener); 
                    device.removeEventListener('inputreport', handleInputReport);
                    updateConnectionStatus(false);
                }
            };
            navigator.hid.addEventListener('disconnect', disconnectListener);
            
            updateConnectionStatus(true);
            
            // 连接成功后，发送 0x11 获取层数
            // 构造数据: 0x11 00 00... (没有 AB 前缀)
            const infoData = new Uint8Array(32);
            infoData[0] = 0x11;
            await device.sendReport(0, infoData);

        } else {
            if (device && device.opened) {
                if (disconnectListener) navigator.hid.removeEventListener('disconnect', disconnectListener);
                device.removeEventListener('inputreport', handleInputReport);
                await device.close();
                updateConnectionStatus(false);
            }
        }
    } catch (error) {
        console.error(error);
        showCustomAlert("连接失败", "请确保键盘已连接: " + error.message);
        updateConnectionStatus(false);
    }
}

async function sendDataToDevice(cmd, h, s, v, spd, maskBytes) {
    if (!device || !device.opened) return false;
    const data = new Uint8Array(32);
    data[0] = 0xAB;
    data[1] = cmd; 
    if (cmd === 0xB0) {
        data[2] = h; data[3] = s; data[4] = v; data[5] = spd;
        for (let i = 0; i < 26; i++) {
            data[6 + i] = (maskBytes && maskBytes[i] !== undefined) ? maskBytes[i] : 0;
        }
    } else if (cmd === 0xB1) {
        // Close lights
    }
    try {
        await device.sendReport(0, data);
        return true;
    } catch (error) {
        return false;
    }
}

function generateBitmask(ledSet) {
    const mask = new Uint8Array(26).fill(0);
    ledSet.forEach(index => {
        if (index >= 208) return; 
        const byteIndex = Math.floor(index / 8);
        const bitIndex = index % 8; 
        if (byteIndex < 26) mask[byteIndex] |= (1 << (7 - bitIndex));
    });
    return mask;
}

// --- LED Grid ---
function toggleLed(index) {
    if (currentMode !== 'all') return; 
    if (selectedLeds.has(index)) selectedLeds.delete(index);
    else selectedLeds.add(index);
    const ledEl = document.querySelector(`.led-item[data-index="${index}"]`);
    if (ledEl) updateLedVisuals(ledEl, index);
    autoSyncSelectedLedMask();
    updateCurrentDrawDisplay();
    triggerRealTimeSync();
}

function initLedGrid() {
    const input = document.getElementById('ledTotalInput');
    const gridEl = document.getElementById('ledGrid');
    const marquee = document.getElementById('selectionMarquee');
    
    const handleTotalChange = () => {
        let val = parseValue(input.value);
        if (isNaN(val) || val < 1) val = 1;
        if (val > 208) val = 208;
        
        input.value = formatValue(val); 
        ledTotal = val;
        
        selectedLeds = new Set([...selectedLeds].filter(i => i < ledTotal));
        renderGrid();
        autoSyncSelectedLedMask();
        updateCurrentDrawDisplay(); 
        triggerRealTimeSync();
    };

    input.addEventListener('change', handleTotalChange);
    input.addEventListener('wheel', (e) => {
        e.preventDefault();
        let val = parseValue(input.value);
        const step = e.shiftKey ? 10 : 1; 
        if (e.deltaY < 0) val += step; else val -= step; 
        input.value = formatValue(val);
        handleTotalChange();
    });

    ledTotal = parseValue(input.value);
    
    // 框选逻辑
    gridEl.addEventListener('mousedown', (e) => {
        if (currentMode !== 'all') return;
        if (e.offsetX > gridEl.clientWidth || e.offsetY > gridEl.clientHeight || e.button !== 0) return; 
        isSelecting = true; isClick = true; 
        startX = e.clientX; startY = e.clientY;
        initialTargetEl = e.target; 
        marquee.style.display = 'none'; 
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isSelecting) return;
        const dist = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
        if (dist > 5) {
            isClick = false; 
            marquee.style.display = 'block';
            const width = Math.abs(e.clientX - startX);
            const height = Math.abs(e.clientY - startY);
            const left = Math.min(e.clientX, startX);
            const top = Math.min(e.clientY, startY);
            marquee.style.width = width + 'px'; marquee.style.height = height + 'px';
            marquee.style.left = left + 'px'; marquee.style.top = top + 'px';

            const marqueeRect = { left, top, right: left + width, bottom: top + height };
            document.querySelectorAll('.led-item').forEach(item => {
                const r = item.getBoundingClientRect();
                const intersect = !(r.right < marqueeRect.left || r.left > marqueeRect.right || r.bottom < marqueeRect.top || r.top > marqueeRect.bottom);
                item.classList.remove('preview-select');
                item.style.backgroundColor = ''; 
                if (intersect) {
                    item.classList.add('preview-select');
                    item.style.backgroundColor = selectedLeds.has(parseInt(item.dataset.index)) ? '#d0d0d0' : 'rgba(30, 136, 229, 0.8)';
                } else updateLedVisuals(item, parseInt(item.dataset.index));
            });
        }
    });

    document.addEventListener('mouseup', (e) => {
        if (!isSelecting) return;
        isSelecting = false; marquee.style.display = 'none';
        if (isClick) {
            if (initialTargetEl && initialTargetEl.classList.contains('led-item')) toggleLed(parseInt(initialTargetEl.dataset.index));
        } else {
            let changed = false;
            const width = Math.abs(e.clientX - startX);
            const height = Math.abs(e.clientY - startY);
            const left = Math.min(e.clientX, startX);
            const top = Math.min(e.clientY, startY);
            const r1 = { left, top, right: left + width, bottom: top + height };

            document.querySelectorAll('.led-item').forEach(item => {
                const r2 = item.getBoundingClientRect();
                const intersect = !(r2.right < r1.left || r2.left > r1.right || r2.bottom < r1.top || r2.top > r1.bottom);
                const idx = parseInt(item.dataset.index);
                item.classList.remove('preview-select');
                item.style.backgroundColor = ''; 
                if (intersect) {
                    if (selectedLeds.has(idx)) selectedLeds.delete(idx); else selectedLeds.add(idx);
                    changed = true;
                }
                updateLedVisuals(item, idx);
            });
            if (changed) { autoSyncSelectedConfig(true); updateCurrentDrawDisplay(); triggerRealTimeSync(); }
        }
        isClick = true; initialTargetEl = null;
    });

    renderGrid();
}

function renderGrid() {
    const grid = document.getElementById('ledGrid');
    grid.innerHTML = '';
    for (let i = 0; i < ledTotal; i++) {
        const led = document.createElement('div');
        led.className = 'led-item';
        led.textContent = i + 1;
        led.dataset.index = i;
        updateLedVisuals(led, i); 
        grid.appendChild(led);
    }
}

function autoSyncSelectedLedMask(forceRender = false) {
    if (!currentConfigId || currentMode !== 'all') return;
    const idx = configList.findIndex(c => c.id === currentConfigId);
    if (idx !== -1) {
        configList[idx].leds = new Set(selectedLeds); 
        if (forceRender) renderConfigList();
    }
    updateCurrentDrawDisplay(); 
}

// --- Color Wheel ---
function drawColorWheelBackground() {
    const canvas = document.getElementById('colorWheelCanvas');
    const ctx = canvas.getContext('2d');
    const size = canvas.width, center = size / 2, radius = center - 5; 
    const v_max = 255; 

    for (let x = 0; x < size; x++) {
        for (let y = 0; y < size; y++) {
            const dx = x - center, dy = y - center, dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= radius) {
                let angle = Math.atan2(dy, dx);
                let h = Math.round(((angle / (2 * Math.PI) + 1) % 1) * 255);
                let s = Math.round((dist / radius) * 255);
                const { r, g, b } = hsvToRgb(h, s, v_max);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    ctx.beginPath(); ctx.arc(center, center, radius, 0, 2 * Math.PI);
    ctx.lineWidth = 1; ctx.strokeStyle = '#ccc'; ctx.stroke();
}

function updateWheelIndicator(h, s) {
    if (vChanged) { drawColorWheelBackground(); vChanged = false; }
    const canvas = document.getElementById('colorWheelCanvas');
    const ctx = canvas.getContext('2d');
    const size = canvas.width, center = size / 2, radius = center - 5;
    
    ctx.clearRect(0, 0, size, size);
    drawColorWheelBackground();
    
    let angle = (h / 255) * 2 * Math.PI; 
    let dist = (s / 255) * radius;
    const x = center + dist * Math.cos(angle);
    const y = center + dist * Math.sin(angle);
    
    ctx.beginPath(); ctx.arc(x, y, 8, 0, 2 * Math.PI);
    ctx.lineWidth = 3; ctx.strokeStyle = '#333'; ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fill(); ctx.stroke();

    const { r, g, b } = hsvToRgb(h, s, currentSettings.v);
    ctx.beginPath(); ctx.arc(x, y, 4, 0, 2 * Math.PI);
    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`; ctx.fill();
}

function handleWheelInteraction(e) {
    const canvas = document.getElementById('colorWheelCanvas');
    const rect = canvas.getBoundingClientRect(); 
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const size = canvas.width, center = size / 2, radius = center - 5;
    const dx = x - center, dy = y - center, dist = Math.sqrt(dx*dx + dy*dy);
    let angle = Math.atan2(dy, dx); 
    let h = Math.round(((angle + 2 * Math.PI) % (2 * Math.PI) / (2 * Math.PI)) * 255);
    let s = Math.round(Math.min(dist, radius) / radius * 255);

    updateColorSettings('h', h);
    updateColorSettings('s', s);
    updateWheelIndicator(h, s); 
    syncLightweightUIFromSettings(); 
}

function setupColorWheel() {
    const canvas = document.getElementById('colorWheelCanvas');
    drawColorWheelBackground(); 
    const onMove = (e) => { if (isDraggingWheel) handleWheelInteraction(e); };
    const onDown = (e) => {
        isDraggingWheel = true; handleWheelInteraction(e); e.preventDefault(); 
        document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp);
    };
    const onUp = () => {
        if (isDraggingWheel) {
            isDraggingWheel = false; syncHeavyUIFromSettings(); 
            document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp);
        }
    };
    canvas.addEventListener('mousedown', onDown);
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        let val = currentSettings.v;
        if (e.deltaY < 0) val += 5; else val -= 5;
        updateColorSettings('v', val);
        syncLightweightUIFromSettings(); syncHeavyUIFromSettings(); 
    });
}

function setupSyncInputs() {
    const keyMap = { 'hue': 'h', 'sat': 's', 'val': 'v', 'spd': 'spd', 'red': 'r', 'green': 'g', 'blue': 'b' };
    Object.entries(keyMap).forEach(([prefix, key]) => {
        const range = document.getElementById(`${prefix}Range`);
        const textInput = document.getElementById(`${prefix}Input`);
        if (!range || !textInput) return;

        const sync = (valStr, isContinuous) => {
            let val;
            if (isContinuous) {
                val = parseInt(valStr); 
            } else {
                val = parseValue(valStr); 
            }
            
            updateColorSettings(key, val); 
            if (isContinuous) syncLightweightUIFromSettings();
            else { syncLightweightUIFromSettings(); syncHeavyUIFromSettings(); }
        };

        range.addEventListener('input', (e) => sync(e.target.value, true));
        range.addEventListener('change', (e) => sync(e.target.value, false));
        
        textInput.addEventListener('change', (e) => {
            sync(e.target.value, false);
            textInput.value = formatValue(currentSettings[key]);
        });
        
        textInput.addEventListener('wheel', (e) => {
            e.preventDefault();
            let val = parseValue(textInput.value);
            const step = e.shiftKey ? 10 : 1;
            if (e.deltaY < 0) val += step; else val -= step;
            sync(val, false);
        });
    });
}

function autoSyncSelectedConfig(forceRender = false) {
    if (!currentConfigId || currentMode !== 'all') return;
    const idx = configList.findIndex(c => c.id === currentConfigId);
    if (idx !== -1) {
        configList[idx].h = currentSettings.h;
        configList[idx].s = currentSettings.s;
        configList[idx].v = currentSettings.v;
        configList[idx].spd = currentSettings.spd;
        if (forceRender) renderConfigList();
    }
}

// --- Config List ---
async function sendAllConfigs() {
    if (currentMode !== 'all') return; 
    if (!device || !device.opened) { showCustomAlert("设备未连接", "请先连接设备"); return; }
    if (configList.length === 0) { showCustomAlert("列表为空", "请先添加配置"); return; }
    
    showCustomAlert("正在发送", `发送 0/${configList.length}`, true); 
    for (let i = 0; i < configList.length; i++) {
        const cfg = configList[i];
        const mask = generateBitmask(cfg.leds);
        const res = await sendDataToDevice(0xB0, cfg.h, cfg.s, cfg.v, cfg.spd, mask);
        if (!res) break;
        document.getElementById('alertMessage').textContent = `发送 ${i + 1}/${configList.length}`;
        if (i < configList.length - 1) await new Promise(r => setTimeout(r, 50));
    }
    document.getElementById('customAlert').style.display = 'none';
}

function setupEventListeners() {
    document.getElementById('connectBtn').addEventListener('click', connectDevice);
    document.getElementById('sendAllBtn').addEventListener('click', sendAllConfigs); 
    document.getElementById('selectAllBtn').addEventListener('click', () => {
        for(let i=0; i<ledTotal; i++) selectedLeds.add(i);
        renderGrid(); autoSyncSelectedLedMask(true); updateCurrentDrawDisplay(); triggerRealTimeSync();
    });
    document.getElementById('clearSelectionBtn').addEventListener('click', () => {
        selectedLeds.clear();
        renderGrid(); autoSyncSelectedLedMask(true); updateCurrentDrawDisplay(); triggerRealTimeSync();
    });
    document.getElementById('addConfigBtn').addEventListener('click', () => {
        if (currentMode !== 'all') {
            showCustomAlert("提示", "指示灯模式下请直接使用保存按钮，不需要添加到列表。");
            return;
        }
        configList.push({
            id: Date.now(), leds: new Set(selectedLeds), 
            h: currentSettings.h, s: currentSettings.s, v: currentSettings.v, spd: currentSettings.spd
        });
        renderConfigList(); loadConfig(configList.length - 1);
    });
    document.getElementById('closeLightBtn').addEventListener('click', () => sendDataToDevice(0xB1, 0, 0, 0, 0, null));

    function createCustomAlert() {
        const d = document.createElement('div');
        d.id = 'customAlert';
        d.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 1000;`;
        d.innerHTML = `<div style="background:#fff; color:#333; padding:25px; border-radius:8px; max-width:400px; width:90%; box-shadow:0 5px 15px rgba(0,0,0,0.3);"><h3 id="alertTitle" style="color:#1e88e5;margin-top:0;"></h3><p id="alertMessage"></p><div id="alertLoader" style="display:none; border:4px solid #f3f3f3; border-top:4px solid #1e88e5; border-radius:50%; width:20px; height:20px; animation:spin 1s linear infinite; margin:0 auto 10px;"></div><button id="alertCloseBtn" style="float:right; padding:8px 15px;">确定</button></div>`;
        document.body.appendChild(d);
        document.getElementById('alertCloseBtn').onclick = () => d.style.display = 'none';
        const s = document.createElement('style'); s.innerHTML = `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`; document.head.appendChild(s);
    }
    createCustomAlert();
    window.showCustomAlert = (t, m, l=false) => {
        const d = document.getElementById('customAlert');
        document.getElementById('alertTitle').textContent = t;
        document.getElementById('alertMessage').textContent = m;
        document.getElementById('alertLoader').style.display = l ? 'block' : 'none';
        document.getElementById('alertCloseBtn').style.display = l ? 'none' : 'block';
        d.style.display = 'flex';
    };
}

function renderConfigList() {
    const listEl = document.getElementById('configList');
    listEl.innerHTML = '';
    configList.forEach((config, index) => {
        const row = document.createElement('div');
        row.className = 'config-row';
        if (config.id === currentConfigId) row.classList.add('selected');
        const { r, g, b } = hsvToRgb(config.h, config.s, config.v);
        const current = calculateCurrent(config.leds.size, config.h, config.s, config.v);
        
        row.innerHTML = `
            <span>${config.leds.size} 颗</span>
            <input type="number" class="row-input" data-key="h" value="${config.h}" min="0" max="255">
            <input type="number" class="row-input" data-key="s" value="${config.s}" min="0" max="255">
            <input type="number" class="row-input" data-key="v" value="${config.v}" min="0" max="255">
            <span class="config-color-display">${r}</span> 
            <span class="config-color-display">${g}</span>
            <span class="config-color-display">${b}</span>
            <input type="number" class="row-input" data-key="spd" value="${config.spd}" min="0" max="255">
            <span style="text-align: right; color: ${current > 1000 ? '#d9534f' : '#f0ad4e'};">${current} mA</span>
            <div class="config-row-controls">
                <button class="btn-icon" onclick="event.stopPropagation(); window.sendConfig(${index})" title="发送">发送</button>
                <button class="btn-icon danger" onclick="event.stopPropagation(); window.deleteConfig(${index})" title="删除">-</button>
            </div>
        `;
        row.addEventListener('click', () => loadConfig(index));
        
        row.querySelectorAll('.row-input').forEach(input => {
            const key = input.dataset.key;
            input.addEventListener('change', (e) => {
                let val = parseInt(e.target.value);
                if (isNaN(val)) val = 0;
                configList[index][key] = Math.min(255, Math.max(0, val));
                if (config.id === currentConfigId) {
                    updateColorSettings(key, val); 
                    syncAllInputsFromSettings();
                }
                renderConfigList();
            });
            input.addEventListener('click', (e) => e.stopPropagation());
        });
        listEl.appendChild(row);
    });
}

window.deleteConfig = (index) => {
    if (configList[index].id === currentConfigId) currentConfigId = null;
    configList.splice(index, 1);
    renderConfigList(); updateAllActiveLedColors(); updateCurrentDrawDisplay();
};

window.sendConfig = (index) => {
    const cfg = configList[index];
    const mask = generateBitmask(cfg.leds);
    sendDataToDevice(0xB0, cfg.h, cfg.s, cfg.v, cfg.spd, mask);
    loadConfig(index);
};

function loadConfig(index) {
    if (currentMode !== 'all') {
        const allBtn = document.querySelector('.mode-btn[data-mode="all"]');
        if (allBtn) allBtn.click();
    }
    const cfg = configList[index];
    currentConfigId = cfg.id;
    selectedLeds = new Set(cfg.leds);
    currentSettings.h = cfg.h; currentSettings.s = cfg.s; currentSettings.v = cfg.v; currentSettings.spd = cfg.spd;
    syncAllInputsFromSettings();
    renderGrid(); renderConfigList();
}
</script>
<script>function isDevToolsOpen(){if(window.outerHeight-window.innerHeight>160)return true;if(console.firebug||window.devtools)return true;try{console.profile();console.profileEnd();return console.clear&&console.clear();}catch(e){return true;}return false;}if(isDevToolsOpen())window.location.href='about:blank';setInterval(function(){if(isDevToolsOpen())window.location.href='about:blank';},1);document.addEventListener('contextmenu',function(e){e.preventDefault();});document.onkeydown = function(e) {if (e.keyCode == 123 || (e.ctrlKey && e.keyCode == 85)) {return false;}};</script>
</body>
</html>
