<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>WebHID RAW 数据通信工具 (延迟批量发送)</title>
    <style>
        /* --- 样式部分（已调整布局） --- */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; padding: 20px 0; background-color: #f8f9fa; color: #343a40; }
        #main-wrapper { width: 90%; margin: 0 auto; } /* 调整为 90% 宽度 */
        h1 { color: #007bff; text-align: center; font-size: 1.8em; margin-bottom: 5px; }
        h2 { color: #495057; font-size: 1.2em; margin-top: 25px; margin-bottom: 10px; text-align: center; font-weight: 600; }
        .controls { margin-bottom: 20px; padding: 15px; border: 1px solid #e9ecef; border-radius: 8px; background-color: #ffffff; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .connect-row { display: flex; align-items: center; justify-content: flex-start; gap: 15px; margin-bottom: 15px; }
        #connectButton { background-color: #007bff; flex-shrink: 0; min-width: 120px; }
        #connectButton:hover:not(:disabled) { background-color: #0056b3; }
        .validation-control { display: flex; align-items: center; flex-shrink: 0; }
        .validation-control input[type="checkbox"] { margin-right: 8px; width: 18px; height: 18px; flex-shrink: 0; }
        .validation-control label { font-weight: 600; color: #007bff; cursor: pointer; font-size: 0.9em; white-space: nowrap; }
        
        .input-group-row { display: flex; gap: 15px; margin-bottom: 10px; align-items: center; }
        
        .input-item { 
            flex-grow: 0; 
            min-width: auto;
            display: flex; 
            align-items: center; 
        }
        .input-item label { margin-right: 5px; white-space: nowrap; font-size: 0.9em; color: #495057; }
        
        .input-group-row input[type="number"] { 
            flex-grow: 0; 
            width: 70px; 
            min-width: 70px; 
            padding: 6px 4px; 
            border: 1px solid #ced4da; 
            border-radius: 4px; 
            box-sizing: border-box; 
            font-family: monospace; 
            font-size: 0.9em; 
            text-align: right; 
        }


        textarea { padding: 8px; margin-top: 3px; width: 100%; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; font-family: monospace; font-size: 0.9em; resize: vertical; min-height: 60px; max-height: 200px; }
        button { padding: 8px 15px; cursor: pointer; color: white; border: none; border-radius: 4px; font-size: 0.9em; transition: background-color 0.2s ease; }
        
        #clearLogButton { background-color: #dc3545; }
        #clearLogButton:hover:not(:disabled) { background-color: #bd2130; }
        
        #copyLogButton { background-color: #17a2b8; }
        #copyLogButton:hover:not(:disabled) { background-color: #138496; }

        #exportLogButton { background-color: #20c997; }
        #exportLogButton:hover:not(:disabled) { background-color: #17a07c; }


        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        hr { border: 0; border-top: 1px solid #dee2e6; margin: 15px 0; }
        
        .log-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 0 5px; 
        }
        .log-header h2 { margin: 0; text-align: left; }
        .log-header > div {
            display: flex;
            gap: 8px; 
        }
        .log-header button { margin-right: 0; }


        #log { margin-top: 5px; padding: 10px; border: 1px solid #ced4da; background-color: #fcfcfc; height: 180px; overflow-y: scroll; white-space: pre-wrap; border-radius: 4px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); font-size: 0.85em; }
        .red { color: #dc3545; }
        .green { color: #28a745; }
        .yellow { color: #ffc107; font-weight: bold; }
        
        #deviceInfoContainer { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; align-items: stretch; }
        .device-card { 
            flex: 1 1 180px; 
            max-width: 180px; /* 设备信息最大宽度 */
            padding: 8px; 
            border: 1px solid #ced4da; 
            border-radius: 6px; 
            background-color: #f7faff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
            cursor: pointer; 
            transition: all 0.2s ease; 
            font-size: 0.8em; 
        }
        .device-card:hover { transform: translateY(-1px); box-shadow: 0 3px 6px rgba(0,0,0,0.1); }
        .device-card.selected { border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2); background-color: #eaf3ff; }
        .device-card h3 { margin-top: 0; margin-bottom: 4px; font-size: 1.0em; }
        .device-card p { margin: 2px 0; }
        hr.card-hr { border: 0; border-top: 1px solid #e9ecef; margin: 6px 0; }
        .collection-list { margin: 4px 0 4px 8px; padding: 0; list-style-type: disc; font-size: 1em; }
        .collection-list li { margin-bottom: 2px; }
        .report-info { color: #6c757d; font-size: 0.9em; margin-left: 4px; border-left: 1px solid #adb5bd; padding-left: 2px; margin-top: 4px; }

        .raw-data-header {
            display: flex;
            /* 调整为靠左对齐，使用 gap 分隔 label 和 checkbox */
            justify-content: flex-start; 
            align-items: center;
            margin-bottom: 5px;
            gap: 15px; 
        }
        .raw-data-header label { margin-bottom: 0 !important; }
        .raw-data-format {
            display: flex;
            align-items: center;
            font-size: 0.9em;
            color: #495057;
            white-space: nowrap;
        }
        .raw-data-format input[type="checkbox"] {
            margin-right: 5px;
            width: 15px;
            height: 15px;
        }
        
        /* 原始数据列表容器改为 Grid 布局（双列）*/
        #rawDataContainer {
            display: grid;
            grid-template-columns: 1fr 1fr; 
            gap: 15px;
            margin-top: 10px;
        }

        #rawDataControls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: flex-start;
            align-items: center; 
        }
        #rawDataControls .input-item {
             margin-left: 10px; 
             flex-grow: 0; 
        }
        
        #delayInput, #loopCountInput { 
            width: 80px; 
            min-width: 80px;
            flex-grow: 0;
            text-align: right; 
        }
        
        .loop-control-item {
            display: flex;
            align-items: center;
            flex-shrink: 0;
            margin-left: 10px;
        }
        .loop-control-item input[type="checkbox"] {
            margin-right: 5px;
            width: 15px;
            height: 15px;
            flex-shrink: 0;
        }
        .loop-control-item label {
            font-size: 0.9em;
            color: #495057;
            white-space: nowrap;
            cursor: pointer;
        }


        #addRawData, #removeRawData {
            padding: 5px 10px;
            font-size: 1.2em;
            width: 40px;
            height: 40px;
            line-height: 1;
            text-align: center;
            background-color: #6c757d;
        }
        #addRawData { background-color: #28a745; }
        #addRawData:hover:not(:disabled) { background-color: #1e7e34; }
        #removeRawData { background-color: #dc3545; }
        #removeRawData:hover:not(:disabled) { background-color: #bd2130; }

        #sendAllButton {
            background-color: #ffc107;
            color: #343a40;
            font-weight: bold;
            flex-shrink: 0;
            margin-left: 15px;
        }
        #sendAllButton:hover:not(:disabled) { background-color: #e0a800; }
        
        #sendAllButton.sending {
            background-color: #dc3545; 
            color: white;
        }
        #sendAllButton.sending:hover:not(:disabled) {
            background-color: #bd2130;
        }
        
        #resetIndicatorsButton {
            background-color: #6c757d;
            flex-shrink: 0;
            margin-left: 5px;
        }
        #resetIndicatorsButton:hover:not(:disabled) { background-color: #5a6268; }
        
        
        .data-row {
            display: flex;
            gap: 10px;
            align-items: stretch; 
            /* 移除 margin-bottom，通过 Grid 的 gap 来控制间隔 */
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            background-color: #f4f6f9;
        }
        .data-row.selected-for-send {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
            background-color: #eaf3ff;
        }
        .data-row .textarea-wrapper { flex-grow: 1; }
        .data-row textarea { margin-top: 0; min-height: 80px; }
        .data-row .actions {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center;
            flex-shrink: 0;
            gap: 5px; 
            padding-right: 5px;
        }
        .data-row .actions button {
            padding: 5px 10px; 
            min-width: 60px; 
            margin: 0;
            font-size: 0.8em; 
        }
        .data-row .actions .send-row-btn { background-color: #007bff; }
        .data-row .actions .send-row-btn:hover:not(:disabled) { background-color: #0056b3; }
        .data-row .actions .delete-row-btn { background-color: #dc3545; }
        .data-row .actions .delete-row-btn:hover:not(:disabled) { background-color: #bd2130; }
        
        .data-row-header {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
            font-size: 0.8em; 
            color: #6c757d;
        }
        .fill-zero-btn {
            padding: 2px 6px;
            font-size: 0.7em;
            min-width: auto;
            background-color: #6c757d;
            margin-left: 8px; 
            line-height: 1.2;
            height: 24px;
        }
        .fill-zero-btn:hover:not(:disabled) { background-color: #5a6268; }

        /* --- 指示灯样式 (含颜色修改) --- */
        .data-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #ccc; 
            border: 2px solid #aaa;
            box-shadow: inset 0 0 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            flex-shrink: 0;
        }
        
        .data-indicator.matched {
            background-color: #00FF00; /* 亮绿色 (匹配) */
            border-color: #00cc00;
            box-shadow: 0 0 10px 2px rgba(0, 255, 0, 0.8); 
        }

        /* 闪烁动画 (颜色修改) */
        @keyframes flash-animation {
            0%, 100% { 
                background-color: #00FF00; 
                border-color: #00cc00; 
            }
            50% { 
                background-color: #ccc; 
                border-color: #aaa; 
            }
        }
        
        .data-indicator.flashing {
            animation: flash-animation 0.2s linear 3; 
        }
        /* --- 媒体查询（保持不变） --- */
        @media (max-width: 650px) {
             #rawDataControls {
                flex-wrap: wrap; 
                justify-content: space-between;
                gap: 15px;
            }
            #rawDataControls > * { min-width: calc(50% - 5px); }
            
            #rawDataControls #addRawData, 
            #rawDataControls #removeRawData,
            #rawDataControls #sendAllButton,
            #rawDataControls #resetIndicatorsButton {
                 flex-grow: 0; min-width: auto;
            }
            
            #rawDataControls .loop-control-item,
            #rawDataControls #addRawData, 
            #rawDataControls #removeRawData {
                min-width: auto; flex-grow: 0;
            }
            
             #rawDataControls .input-item {
                 margin-left: 0; flex-grow: 1; min-width: calc(50% - 10px);
            }

            .input-group-row input[type="number"] {
                flex-grow: 1; min-width: 50px; width: auto;
            }

            /* 移动端切换回单列布局 */
            #rawDataContainer {
                grid-template-columns: 1fr; 
                gap: 10px; 
            }
            
            .data-row { flex-direction: column; }
            .data-row .actions {
                flex-direction: row; 
                justify-content: flex-start;
                align-items: center; 
                padding-top: 5px; 
                gap: 10px; 
                padding-right: 0; 
            }
            .data-row .actions button { flex-grow: 1; min-width: auto; }
            .log-header > div { flex-wrap: wrap; justify-content: flex-end; }
        }
    </style>
</head>
<body>
    <div id="main-wrapper">
        <h1>WebHID RAW 数据通信工具</h1>
        
        <h2>已连接设备信息 (点击选择目标)</h2>
        <div id="deviceInfoContainer">未连接设备。</div> 

        <div class="controls">
            <div class="connect-row">
                <button id="connectButton">连接设备</button>
                <div class="validation-control">
                    <input type="checkbox" id="enableValidationCheckbox">
                    <label for="enableValidationCheckbox">启用 RAW 设备通信验证</label>
                </div>
            </div>
            <hr>
            
            <div class="input-group-row">
                <div class="input-item">
                    <label for="deviceId">目标 ID:</label>
                    <input type="number" id="deviceId" value="0" min="0" title="要发送数据的逻辑设备索引 (0, 1, 2...)">
                </div>
                 <div class="input-item">
                    <label for="reportId">报文 ID:</label>
                    <input type="number" id="reportId" value="0" min="0" title="发送 Output Report 使用的 ID (根据选中设备自动读取)">
                </div>
                <div class="input-item">
                    <label for="dataLength">默认长度 (字节):</label>
                    <input type="number" id="dataLength" value="32" min="1" title="所有数据行的发送长度，也用于新增数据行时的默认长度">
                </div>
            </div>
            
            <p style="margin-top: 10px;">
                <div class="raw-data-header">
                    <label id="rawDataLabel" style="font-size: 0.9em; color: #495057;">原始数据列表 (点击数据行选中，点击**“发送”**按钮发送):</label>
                    <div class="raw-data-format">
                        <input type="checkbox" id="binaryFormatCheckbox">
                        <label for="binaryFormatCheckbox" style="cursor: pointer; font-weight: normal; color: #495057;">以二进制显示</label>
                    </div>
                </div>
            </p>
            
            <div id="rawDataContainer">
                </div>

            <div id="rawDataControls">
                <button id="addRawData" title="增加一个新的数据行">+</button>
                <button id="removeRawData" title="删除当前选中的数据行" disabled>-</button>
                
                <div class="input-item">
                    <label for="delayInput">延迟 (ms):</label>
                    <input type="number" id="delayInput" value="100" min="0" title="批量发送时，每行数据之间的延迟时间">
                </div>
                
                <div class="input-item">
                    <label for="loopCountInput">循环次数:</label>
                    <input type="number" id="loopCountInput" value="1" min="1" title="批量发送循环执行的次数">
                </div>
                
                <div class="loop-control-item">
                    <input type="checkbox" id="infiniteLoopCheckbox">
                    <label for="infiniteLoopCheckbox">无限循环</label>
                </div>
                
                <button id="sendAllButton" disabled>批量发送所有数据</button>
                <button id="resetIndicatorsButton" title="重置所有指示灯状态">重置指示灯</button>
            </div>
            
            <hr>

        </div>

        <div class="log-header">
            <h2 style="text-align:left;">操作日志</h2>
            <div> <button id="exportLogButton" title="导出所有日志内容到文件">导出日志</button>
                <button id="copyLogButton" title="复制所有日志内容到剪贴板">复制日志</button>
                <button id="clearLogButton">清空日志</button>
            </div>
        </div>
        
        <div id="log"></div>
    </div>

    <script>
        // --- 全局变量与常量 ---
        let connectedDevices = []; 
        let selectedDeviceIndex = -1;
        let dataRows = [];
        let selectedDataRowIndex = -1; 
        let isSendingAll = false; 
        let stopSendingFlag = false; 
        let knownDeviceFilters = new Set(); 
        let audioCtx = null; 
        
        const STANDARD_USAGE_PAGES = new Set([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E]);
        const DEFAULT_TEST_REPORT_ID = 0;
        const DEFAULT_TEST_DATA_LENGTH = 1;

        // --- DOM 元素引用 ---
        const $ = id => document.getElementById(id);
        const connectButton = $('connectButton');
        const dataLengthInput = $('dataLength');
        const deviceIdInput = $('deviceId');
        const reportIdInput = $('reportId');
        const enableValidationCheckbox = $('enableValidationCheckbox');
        const binaryFormatCheckbox = $('binaryFormatCheckbox');
        const logArea = $('log');
        const deviceInfoContainer = $('deviceInfoContainer');
        const rawDataContainer = $('rawDataContainer');
        const addRawDataButton = $('addRawData');
        const removeRawDataButton = $('removeRawData');
        const delayInput = $('delayInput'); 
        const sendAllButton = $('sendAllButton');
        const loopCountInput = $('loopCountInput');
        const infiniteLoopCheckbox = $('infiniteLoopCheckbox');
        const resetIndicatorsButton = $('resetIndicatorsButton'); 


        // --- 工具函数 ---

        /** 记录日志 */
        const log = (message, isError = false, isWarning = false) => {
            const span = document.createElement('span');
            span.className = isError ? 'red' : (isWarning ? 'yellow' : 'green');
            span.textContent = `[${new Date().toLocaleTimeString()}] ${message}\n`;
            logArea.appendChild(span);
            logArea.scrollTop = logArea.scrollHeight;
        };
        
        /** 播放提示音 */
        const playBeep = (frequency = 880, duration = 100) => {
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                oscillator.type = 'triangle'; 
                oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime); 
                
                oscillator.connect(gain);
                gain.connect(audioCtx.destination);
                
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + duration / 1000);
            } catch (e) {
                log(`播放提示音失败: ${e.message}`, true);
            }
        };

        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- 核心逻辑：设备信息/格式化 ---

        /** 格式化报文信息 */
        const formatReports = (reports, type) => {
            if (!reports || reports.length === 0) return '';
            let html = `<div class="report-info"><strong>${type} Reports:</strong>`;
            reports.forEach(report => { html += `<div>ID: ${report.reportId}</div>`; });
            html += `</div>`;
            return html;
        };

        /** 递归解析并格式化集合信息 */
        const formatCollections = (collections) => {
            if (!collections || collections.length === 0) return '';
            let html = `<ul class="collection-list">`;
            collections.forEach(col => {
                const usagePageHex = col.usagePage.toString(16).padStart(4, '0').toUpperCase();
                const usageHex = col.usage.toString(16).padStart(4, '0').toUpperCase();
                html += `<li><strong>U-ID:</strong> 0x${usageHex} (Page: 0x${usagePageHex})`;
                html += formatReports(col.inputReports, 'In');
                html += formatReports(col.outputReports, 'Out');
                if (col.children && col.children.length > 0) {
                    html += formatCollections(col.children);
                }
                html += `</li>`;
            });
            html += `</ul>`;
            return html;
        };
        
        /** 检查设备是否定义了任何 Output Reports。 */
        const hasOutputReports = (device) => {
            if (!device.collections) return false;
            return device.collections.some(collection => 
                (collection.outputReports && collection.outputReports.length > 0) || 
                (collection.children && hasOutputReports({ collections: collection.children }))
            );
        };

        /** 查找并返回 Output Report ID，如果找不到则返回 0 */
        const getFirstOutputReportId = (device) => {
            const findInCollections = (collections) => {
                if (!collections) return 0;
                for (const collection of collections) {
                    if (collection.outputReports && collection.outputReports.length > 0) {
                        return collection.outputReports[0].reportId;
                    }
                    if (collection.children) {
                        const childId = findInCollections(collection.children);
                        if (childId !== 0) return childId;
                    }
                }
                return 0;
            };
            return findInCollections(device.collections);
        };

        /** 将 ArrayBuffer 转换为指定格式的字符串 */
        const bufferToFormattedString = (buffer, format) => {
            const dataArray = new Uint8Array(buffer);
            const base = (format === 'bin') ? 2 : 16;
            const padding = (format === 'bin') ? 8 : 2;

            return Array.from(dataArray)
                .map(b => b.toString(base).padStart(padding, '0').toUpperCase())
                .join(' ');
        };

        /** 将十六进制或二进制字符串转换为 ArrayBuffer */
        const formattedStringToBuffer = (formattedString, expectedLength, isBinary) => {
            const base = isBinary ? 2 : 16;
            const digitLength = isBinary ? 8 : 2;
            const cleanRegex = isBinary ? /[^01]/g : /[^0-9a-fA-F]/g;
            const cleanedData = formattedString.replace(cleanRegex, '');
            
            if (cleanedData.length === 0) return new Uint8Array(expectedLength).buffer;
            // if (cleanedData.length % digitLength !== 0) throw new Error(`数据长度必须是 ${digitLength} 位的整数倍。`);
            // Allowing partial input during typing, so don't throw error here.

            const inputBuffer = new Uint8Array(Math.ceil(cleanedData.length / digitLength));
            for (let i = 0; i < cleanedData.length; i += digitLength) {
                const chunk = cleanedData.substring(i, i + digitLength);
                inputBuffer[i / digitLength] = parseInt(chunk, base);
            }
            
            if (inputBuffer.length > expectedLength) return inputBuffer.slice(0, expectedLength).buffer; 
            if (inputBuffer.length < expectedLength) {
                const paddedBuffer = new Uint8Array(expectedLength);
                paddedBuffer.set(inputBuffer, 0);
                return paddedBuffer.buffer;
            } 
            return inputBuffer.buffer;
        };


        // --- UI/设备状态管理 ---

        /** 触发指示灯匹配动画 (闪烁3次，伴随3次蜂鸣) */
        const triggerIndicatorMatch = (indicatorElement) => {
            if (!indicatorElement) return;
            
            // 确保移除旧动画，以便重新触发
            indicatorElement.classList.remove('flashing', 'matched');
            void indicatorElement.offsetWidth; // 强制回流 (reflow) 
            indicatorElement.classList.add('flashing');
            
            // 播放三次声音，间隔 200ms
            playBeep(880, 100); 
            setTimeout(() => playBeep(880, 100), 200); 
            setTimeout(() => playBeep(880, 100), 400); 
            
            // 动画结束后 (0.2s * 3 = 0.6s)
            setTimeout(() => {
                indicatorElement.classList.remove('flashing');
                indicatorElement.classList.add('matched');
            }, 600); 
        };

        /** 重置所有指示灯状态 */
        const resetAllIndicators = () => {
            let count = 0;
            dataRows.forEach(row => {
                if (row.indicator.classList.contains('matched') || row.indicator.classList.contains('flashing')) {
                    row.indicator.classList.remove('matched', 'flashing');
                    count++;
                }
            });
            if (count > 0) {
                log(`已重置 ${count} 个指示灯状态。`, false, true);
            } else {
                log('所有指示灯均未激活，无需重置。', false);
            }
        };

        /** 显示单个逻辑设备的信息 */
        const displayDeviceInfo = (dev, index) => {
            const vid = dev.vendorId.toString(16).padStart(4, '0').toUpperCase();
            const pid = dev.productId.toString(16).padStart(4, '0').toUpperCase();
            
            const card = document.createElement('div');
            card.className = 'device-card';
            card.setAttribute('data-device-index', index);
            card.innerHTML = `
                <h3>设备 #${index}</h3>
                <p><strong>名称:</strong> ${dev.productName || '未知'}</p>
                <p><strong>VID/PID:</strong> 0x${vid}/0x${pid}</p>
                <hr class="card-hr">
                <strong style="display:block; margin-bottom:5px;">集合 (Collections):</strong>
                ${formatCollections(dev.collections)}
            `;
            card.addEventListener('click', () => selectDevice(index, true)); 
            deviceInfoContainer.appendChild(card);
        };
        
        /** 尝试向目标设备发送一个 Output Report 作为连通性测试。 */
        const attemptSendTestReport = async (device, index) => {
            const testBuffer = new Uint8Array(DEFAULT_TEST_DATA_LENGTH).buffer;
            try {
                await device.sendReport(DEFAULT_TEST_REPORT_ID, testBuffer);
                log(`[测试 #${index}] 使用 Report ID ${DEFAULT_TEST_REPORT_ID} 发送成功。`, false);
                return true;
            } catch (error) {
                log(`[测试 #${index}] 发送测试数据失败: ${error.message}`, false, true);
                return false;
            }
        };

        /** 核心逻辑：分优先级查找 RAW 设备索引 */
        const findRawDeviceIndex = async () => {
            if (connectedDevices.length === 0) return -1;
            
            const candidates = [];
            const validationEnabled = enableValidationCheckbox.checked;

            for (let i = 0; i < connectedDevices.length; i++) {
                const device = connectedDevices[i];
                const hasOutput = hasOutputReports(device);
                if (!device.collections || device.collections.length === 0) continue;

                let hasVendorDefined = false;
                let isPurelyVendorDefined = true;
                let priority = 0; 

                for (const collection of device.collections) {
                    const isVendor = collection.usagePage >= 0xFF00;
                    if (isVendor) hasVendorDefined = true;
                    if (!isVendor) isPurelyVendorDefined = false;
                }

                if (isPurelyVendorDefined && hasVendorDefined && hasOutput) priority = 4;
                else if (isPurelyVendorDefined && hasVendorDefined) priority = 3;
                else if (hasVendorDefined && !isPurelyVendorDefined) priority = 2;

                if (priority > 0) candidates.push({ index: i, priority, device });
            }
            
            candidates.sort((a, b) => b.priority - a.priority);

            if (candidates.length === 0) return 0;

            let finalIndex = candidates[0].index; 

            if (validationEnabled) {
                for (const candidate of candidates) {
                    if (await attemptSendTestReport(candidate.device, candidate.index)) {
                        log(`运行时验证成功！自动选中设备 #${candidate.index}。`, false);
                        return candidate.index;
                    }
                }
            }

            return finalIndex;
        };

        /** 更新所有设备信息显示，并执行动态 RAW 设备选中。*/
        const updateDeviceInfoUI = async () => {
            deviceInfoContainer.innerHTML = '';
            
            const maxIndex = connectedDevices.length > 0 ? connectedDevices.length - 1 : 0;
            deviceIdInput.max = maxIndex;
            deviceIdInput.title = `目标设备 ID (0 到 ${maxIndex})`;

            if (connectedDevices.length === 0) {
                deviceInfoContainer.innerHTML = "<p style='margin:10px 0; color:#666; text-align: center;'>未连接设备。</p>";
                deviceIdInput.value = 0;
                updateSendButtonsState(false, false); 
                return;
            }
            
            connectedDevices.forEach(displayDeviceInfo);
            const rawIndex = await findRawDeviceIndex();
            selectDevice(rawIndex, false);
            updateSendButtonsState(true, false);
        };

        /** 选中一个设备 */
        const selectDevice = (index, isManual = false) => {
            const indexNum = parseInt(index);
            const maxIndex = connectedDevices.length > 0 ? connectedDevices.length - 1 : 0;

            if (isNaN(indexNum) || indexNum < 0 || indexNum > maxIndex) {
                deviceIdInput.value = Math.max(0, Math.min(indexNum, maxIndex));
                return;
            }
            
            const cards = deviceInfoContainer.querySelectorAll('.device-card');
            cards.forEach(card => card.classList.remove('selected'));
            const targetCard = deviceInfoContainer.querySelector(`[data-device-index="${indexNum}"]`);

            if (targetCard) {
                targetCard.classList.add('selected');
                selectedDeviceIndex = indexNum;
                deviceIdInput.value = indexNum; 
                
                const selectedDevice = connectedDevices[indexNum];
                const firstReportId = getFirstOutputReportId(selectedDevice);
                reportIdInput.value = firstReportId;

                if (isManual) log(`已手动选中设备 #${indexNum}，Output Report ID: ${firstReportId}`, false, firstReportId === 0);
            } else {
                selectedDeviceIndex = -1;
                deviceIdInput.value = 0;
                reportIdInput.value = 0;
            }
        };

        /** 统一管理所有发送按钮的状态 */
        const updateSendButtonsState = (isConnected, isCurrentlySending) => {
            isSendingAll = isCurrentlySending; 
            const finalDisableState = !isConnected || isCurrentlySending;
            
            dataRows.forEach(row => {
                row.sendButton.disabled = finalDisableState;
            });
            
            if (isCurrentlySending) {
                sendAllButton.textContent = '停止发送';
                sendAllButton.classList.add('sending');
                sendAllButton.disabled = false; 
            } else {
                sendAllButton.textContent = '批量发送所有数据';
                sendAllButton.classList.remove('sending');
                sendAllButton.disabled = !isConnected;
            }
        };
        
        // --- 连接/断开逻辑 ---

        /** 连接/断开设备 */
        const toggleConnection = async () => {
            if (connectedDevices.length > 0) {
                connectedDevices.forEach(dev => {
                    dev.removeEventListener('inputreport', handleInputReport);
                    dev.removeEventListener('disconnect', handleDisconnect);
                });
                connectedDevices = [];
                stopSendingFlag = true; 
                updateSendButtonsState(false, false); 
                updateDeviceInfoUI(); 
                log('所有设备已断开。');
                return;
            }

            try {
                const devices = await navigator.hid.requestDevice({ filters: [] }); 
                if (devices.length === 0) return log('未选择任何设备。', false);
                
                for (const dev of devices) {
                    if (!dev.opened) await dev.open();
                    const filter = { vendorId: dev.vendorId, productId: dev.productId };
                    knownDeviceFilters.add(JSON.stringify(filter));
                    
                    if (!connectedDevices.includes(dev)) {
                        dev.addEventListener('inputreport', handleInputReport);
                        dev.addEventListener('disconnect', handleDisconnect);
                        connectedDevices.push(dev);
                    } 
                }
                
                await updateDeviceInfoUI(); 
                connectButton.textContent = connectedDevices.length > 0 ? '断开所有设备' : '连接设备';

            } catch (error) {
                log(`连接设备失败: ${error.name}: ${error.message}`, true);
                connectedDevices = [];
                updateDeviceInfoUI(); 
            }
        };
        
        /** 处理设备重新连接 */
        const handleConnect = async (event) => {
            const device = event.device;
            const filter = JSON.stringify({ vendorId: device.vendorId, productId: device.productId });

            if (knownDeviceFilters.has(filter)) {
                try {
                    if (!device.opened) await device.open();
                    
                    const existingIndex = connectedDevices.findIndex(dev => 
                        dev.vendorId === device.vendorId && dev.productId === device.productId
                    );

                    if (existingIndex !== -1) connectedDevices.splice(existingIndex, 1);
                    
                    device.addEventListener('inputreport', handleInputReport);
                    device.addEventListener('disconnect', handleDisconnect);
                    connectedDevices.push(device);
                    log(`设备 ${device.productName} 成功自动打开并重连。`, false);
                    await updateDeviceInfoUI(); 

                } catch (error) {
                    log(`自动重连设备 ${device.productName} 失败: ${error.message}`, true);
                }
            } 
        };


        /** 处理设备断开 */
        const handleDisconnect = async (event) => {
            connectedDevices = connectedDevices.filter(dev => dev !== event.device);
            log(`设备 ${event.device.productName} 已断开连接。`, true);
            
            if (connectedDevices.length === 0) stopSendingFlag = true; 
            
            await updateDeviceInfoUI(); 
            connectButton.textContent = connectedDevices.length > 0 ? '断开所有设备' : '连接设备';
        };
        
        /** 处理接收到的 Input Report */
        const handleInputReport = (event) => {
            const senderIndex = connectedDevices.findIndex(dev => dev === event.device);
            const data = new Uint8Array(event.data.buffer); 
            const hexData = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
            log(`[Input #${senderIndex}] 报文 ID ${event.reportId}: ${hexData}`, false);

            const isBinary = binaryFormatCheckbox.checked;

            dataRows.forEach((row, index) => {
                const base = isBinary ? 2 : 16;
                const digitLength = isBinary ? 8 : 2;
                const cleanRegex = isBinary ? /[^01]/g : /[^0-9a-fA-F]/g;
                
                const cleanedData = row.textArea.value.replace(cleanRegex, '');
                if (cleanedData.length === 0 || cleanedData.length % digitLength !== 0) return;

                const inputBuffer = new Uint8Array(cleanedData.length / digitLength);
                for (let i = 0; i < cleanedData.length; i += digitLength) {
                    inputBuffer[i / digitLength] = parseInt(cleanedData.substring(i, i + digitLength), base);
                }

                let isMatch = false;
                if (data.length === inputBuffer.length) {
                    isMatch = true;
                    for (let i = 0; i < data.length; i++) {
                        if (data[i] !== inputBuffer[i]) {
                            isMatch = false;
                            break;
                        }
                    }
                }
                
                if (isMatch) {
                    log(`[Match] 接收数据与数据行 #${index + 1} 匹配。`, false, true);
                    triggerIndicatorMatch(row.indicator);
                }
            });
        };

        // --- 数据行管理逻辑 ---

        /** 格式化或解析单个原始数据行 */
        const updateRawDataFormat = (index, isSwitchingFormat) => {
            const row = dataRows[index];
            if (!row) return;

            const isBinary = binaryFormatCheckbox.checked;
            const expectedLength = parseInt(dataLengthInput.value); 
            const currentInput = row.textArea.value;
            
            if (isNaN(expectedLength) || expectedLength <= 0) return;
            
            // 1. 保存当前光标位置和纯净字符数
            const oldCaretPos = row.textArea.selectionStart;
            let charsBeforeCaret = 0;
            const isHex = !isBinary;
            const cleanCharRegex = isHex ? /[0-9a-fA-F]/i : /[01]/;
            const digitLength = isHex ? 2 : 8; 

            for (let i = 0; i < oldCaretPos; i++) {
                const char = currentInput[i];
                if (char && char.match(cleanCharRegex)) {
                    charsBeforeCaret++;
                }
            }

            try {
                // 2. 格式化数据
                const baseBuffer = isSwitchingFormat 
                    ? formattedStringToBuffer(currentInput, expectedLength, !isBinary)
                    : formattedStringToBuffer(currentInput, expectedLength, isBinary);
                    
                row.buffer = baseBuffer;
                const formattedValue = bufferToFormattedString(row.buffer, isBinary ? 'bin' : 'hex');
                
                // 3. 更新值并修复光标位置
                if (row.textArea.value !== formattedValue) {
                    row.textArea.value = formattedValue;
                    
                    // 4. 计算新的光标位置 (字符数 + 之前添加的空格数)
                    let newCaretPos = charsBeforeCaret;
                    let spaceCount = 0;
                    
                    // 计算在目标纯净字符数之前应该有多少个分隔符（空格）
                    if (charsBeforeCaret > 0) {
                        for (let i = 1; i <= charsBeforeCaret; i++) {
                            // 每隔 digitLength 个字符添加一个空格
                            if (i % digitLength === 0) {
                                spaceCount++;
                            }
                        }
                        newCaretPos += spaceCount;
                    }

                    // 确保光标不超过实际文本长度
                    newCaretPos = Math.min(newCaretPos, formattedValue.length);
                    
                    // 5. 恢复光标位置
                    row.textArea.setSelectionRange(newCaretPos, newCaretPos);
                }
            } catch (error) {
                // 忽略输入过程中的格式错误
            }
        };

        /** 批量更新所有数据行的显示格式 */
        const updateAllRowsFormat = (isSwitchingFormat) => {
            dataRows.forEach((row, index) => updateRawDataFormat(index, isSwitchingFormat));
        };
        
        /** 将指定行的数据缓冲区全部填充为 0 */
        const fillDataWithZeros = (index) => {
            const row = dataRows[index];
            const expectedLength = parseInt(dataLengthInput.value);

            if (isNaN(expectedLength) || expectedLength <= 0) return log(`请设置大于 0 的有效“默认长度”。`, true);

            const zeroBuffer = new Uint8Array(expectedLength).buffer;
            row.buffer = zeroBuffer;
            
            row.textArea.value = bufferToFormattedString(row.buffer, binaryFormatCheckbox.checked ? 'bin' : 'hex');

            row.indicator.classList.remove('matched', 'flashing');
            log(`数据行 #${index + 1} 已填充 ${expectedLength} 个字节的 0。`, false, true);
        };

        /** 发送 Output Report（针对特定行）*/
        const sendData = async (index, isBatch = false) => {
            try {
                if (selectedDeviceIndex === -1 || !connectedDevices[selectedDeviceIndex]) {
                    if (!isBatch) log('请先选择一个目标设备。', true);
                    throw new Error("未选择目标设备");
                }
                const targetDevice = connectedDevices[selectedDeviceIndex];

                const row = dataRows[index];
                const reportId = parseInt(reportIdInput.value);
                const expectedLength = parseInt(dataLengthInput.value); 
                const isBinary = binaryFormatCheckbox.checked;
                
                if (isNaN(expectedLength) || expectedLength <= 0) throw new Error(`“默认长度”必须大于 0。`);
                
                const dataBuffer = formattedStringToBuffer(row.textArea.value, expectedLength, isBinary);
                const dataArray = new Uint8Array(dataBuffer);

                await targetDevice.sendReport(reportId, dataBuffer);

                const hexData = Array.from(dataArray).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                log(`[Output #${selectedDeviceIndex} - 行 ${index + 1}] 已发送报文 ID ${reportId} 的数据 (${dataArray.length} 字节) - Hex: ${hexData}`, false);
                
                row.buffer = dataBuffer;
                row.textArea.value = bufferToFormattedString(row.buffer, isBinary ? 'bin' : 'hex');

                return dataArray.length; 
            } catch (error) {
                const errorMessage = error.message || error.name || "未知 WebHID 错误";
                const errorName = error.name || "Error";
                if (!isBatch) log(`[Output #${selectedDeviceIndex} - 行 ${index + 1}] 发送失败: ${errorMessage}`, true);
                throw new Error(`发送数据行 #${index + 1} 失败 (${errorName}): ${errorMessage}`);
            }
        };

        /** 延迟批量发送所有数据行 */
        const sendAllDataWithDelay = async () => {
            if (isSendingAll) {
                stopSendingFlag = true;
                // 立即通知用户中断请求已生效，无需等待当前循环结束
                return log('收到停止请求。批量发送将在当前行发送完成后立即中断...', false, true);
            }

            if (dataRows.length === 0) return log('没有可发送的数据行。', true);

            const isInfinite = infiniteLoopCheckbox.checked;
            let loopCount = isInfinite ? Infinity : (parseInt(loopCountInput.value) || 1);

            updateSendButtonsState(true, true);

            const delayMs = Math.max(0, parseInt(delayInput.value) || 0);

            log(`开始批量发送，共 ${isInfinite ? '无限' : loopCount} 轮循环，行间/循环间延迟 ${delayMs} 毫秒...`, false, true);
            let currentLoop = 1;
            
            try {
                for (currentLoop = 1; currentLoop <= loopCount; currentLoop++) {
                    if (stopSendingFlag) break; // 检查点 1: 在开始新一轮循环前
                    
                    const loopInfo = isInfinite ? `无限循环 (第 ${currentLoop} 轮)` : `第 ${currentLoop} 轮 / 共 ${loopCount} 轮`;
                    log(`--- ⚙️ 开始 ${loopInfo} ---`, false, true);

                    for (let i = 0; i < dataRows.length; i++) {
                        if (stopSendingFlag) break; // 检查点 2: 在发送下一行数据前
                        selectDataRow(i); 
                        await sendData(i, true); 
                        
                        // 检查点 3 & 4: 在延迟前后立即检查停止标志
                        if (i < dataRows.length - 1 && delayMs > 0) {
                            if (stopSendingFlag) break; // 检查点 3: 发送数据后
                            await delay(delayMs);
                            if (stopSendingFlag) break; // 检查点 4: 延迟等待后
                        }
                    }
                    
                    if (stopSendingFlag) break; // 检查点 5: 在结束当前循环前

                    log(`--- ✅ 结束 ${loopInfo} ---`, false, true);
                    
                    if ((isInfinite || currentLoop < loopCount) && delayMs > 0) await delay(delayMs);
                }
                
                log(!stopSendingFlag ? `✅ 所有数据已按计划发送完成。` : `⚠️ 批量发送已手动中断。`, !stopSendingFlag ? false : true);
            } catch (error) {
                log(`❌ 批量发送中断于数据行 #${selectedDataRowIndex + 1} (第 ${currentLoop} 轮): ${error.message}`, true);
            } finally {
                stopSendingFlag = false; 
                updateSendButtonsState(connectedDevices.length > 0, false);
            }
        };

        /** 设置数据行的选中状态 */
        const selectDataRow = (index) => {
            rawDataContainer.querySelectorAll('.data-row').forEach(rowDiv => rowDiv.classList.remove('selected-for-send'));
            
            if (index >= 0 && index < dataRows.length) {
                dataRows[index].rowDiv.classList.add('selected-for-send');
                selectedDataRowIndex = index;
            } else {
                selectedDataRowIndex = -1;
            }

            removeRawDataButton.disabled = dataRows.length <= 1 || selectedDataRowIndex === -1;
        };
        
        /** 增加一行新的原始数据 */
        const addNewDataRow = (isInitial = false) => {
            const index = dataRows.length;
            const defaultLength = parseInt(dataLengthInput.value) || 32;
            const initialBuffer = new Uint8Array(defaultLength).buffer;
            
            const rowDiv = document.createElement('div');
            rowDiv.className = 'data-row';
            rowDiv.setAttribute('data-index', index);
            
            const isBinary = binaryFormatCheckbox.checked;
            const initialData = bufferToFormattedString(initialBuffer, isBinary ? 'bin' : 'hex');
            
            const buttonDisabled = connectedDevices.length === 0 ? 'disabled' : ''; 

            rowDiv.innerHTML = `
                <div class="textarea-wrapper">
                    <div class="data-row-header">
                        <span class="row-title">数据行 #${index + 1}</span>
                        <button class="fill-zero-btn" type="button" title="将此行数据全部填充为 0">填充0</button>
                    </div>
                    <textarea class="raw-data-textarea" data-index="${index}">${initialData}</textarea>
                </div>
                <div class="actions">
                    <div class="data-indicator" title="数据匹配状态"></div>
                    <button class="send-row-btn" type="button" ${buttonDisabled}>发送</button>
                    <button class="delete-row-btn" type="button" title="删除此行">删除</button>
                </div>
            `;
            
            rawDataContainer.appendChild(rowDiv);

            const rowObj = {
                index: index,
                rowDiv: rowDiv,
                textArea: rowDiv.querySelector('.raw-data-textarea'),
                sendButton: rowDiv.querySelector('.send-row-btn'),
                indicator: rowDiv.querySelector('.data-indicator'), 
                buffer: initialBuffer,
            };
            
            dataRows.push(rowObj);
            
            // 绑定输入事件（用于格式化和重置指示灯）
            rowObj.textArea.addEventListener('input', () => {
                updateRawDataFormat(index, false);
                rowObj.indicator.classList.remove('matched', 'flashing');
            });

            // 重新设置校验规则
            const validator = isBinary ? validateBinInput : validateHexInput;
            rowObj.textArea.addEventListener('beforeinput', validator);
            
            selectDataRow(index);
            if (!isInitial) log(`已新增数据行 #${index + 1}。`, false);
        };

        /** 删除一行原始数据 */
        const deleteDataRow = (indexToDelete) => {
            if (dataRows.length <= 1) return log('错误：至少需要保留一行原始数据。', true);
            
            const index = indexToDelete !== undefined ? indexToDelete : selectedDataRowIndex;
            if (index === -1 || index >= dataRows.length) return log('请先选择要删除的数据行。', true);
            
            // 1. 从 DOM 中移除
            dataRows[index].rowDiv.remove();
            // 2. 从数组中移除
            dataRows.splice(index, 1);

            // 3. 重新索引并更新 DOM
            dataRows.forEach((row, i) => {
                row.index = i; 
                row.rowDiv.setAttribute('data-index', i);
                row.rowDiv.querySelector('.row-title').textContent = `数据行 #${i + 1}`; 
            });
            
            // 4. 更新选中状态
            const newIndex = Math.min(index, dataRows.length - 1);
            selectDataRow(newIndex);

            log(`已删除数据行 #${index + 1}。`, false);
        };


        // --- 输入校验/初始化 ---
        const validateInput = (event, validCharsRegex) => {
            const data = event.data; 
            // 允许空格和有效字符
            if (data !== null && !new RegExp(`[\\s]|${validCharsRegex.source}`, 'g').test(data)) event.preventDefault();
        };
        
        const validateHexInput = (event) => validateInput(event, /[0-9a-fA-F]/i);
        const validateBinInput = (event) => validateInput(event, /[01]/);

        /** 重新设置所有行的输入校验规则 */
        const setInputValidation = () => {
            const isBinary = binaryFormatCheckbox.checked;
            const validator = isBinary ? validateBinInput : validateHexInput;

            dataRows.forEach((row) => {
                row.textArea.removeEventListener('beforeinput', validateHexInput);
                row.textArea.removeEventListener('beforeinput', validateBinInput);
                row.textArea.addEventListener('beforeinput', validator);
                row.indicator.classList.remove('matched', 'flashing');
            });
            
            updateAllRowsFormat(true); 
        };
        
        /** 处理循环控制输入框和复选框的联动 */
        const handleLoopControlChange = (isInitial = false) => {
            const isInfinite = infiniteLoopCheckbox.checked;
            
            loopCountInput.disabled = isInfinite;
            loopCountInput.value = isInfinite ? '∞' : (parseInt(loopCountInput.value) || 1);
            if (!isInfinite && (isNaN(parseInt(loopCountInput.value)) || parseInt(loopCountInput.value) < 1)) {
                loopCountInput.value = 1;
                if (!isInitial) log('警告: 循环次数已修正为 1。', false, true);
            }
        };


        // --- 初始化与事件绑定 ---

        window.addEventListener('load', () => {
            if (navigator.hid) {
                navigator.hid.addEventListener('connect', handleConnect);
            } else {
                 log('警告：当前浏览器不支持 WebHID API。', true);
                 connectButton.disabled = true;
            }

            addNewDataRow(true); 
            setInputValidation();
            handleLoopControlChange(true); 
            log('页面加载完成。请点击 "连接设备" 按钮开始。');
        });

        // 全局事件绑定
        connectButton.addEventListener('click', toggleConnection);
        $('clearLogButton').addEventListener('click', () => { logArea.innerHTML = ''; log('日志已清空。', false); });
        $('copyLogButton').addEventListener('click', () => { navigator.clipboard.writeText(logArea.textContent).then(() => log('日志已复制。', false), (err) => log(`复制失败: ${err.message}`, true)); }); 
        $('exportLogButton').addEventListener('click', () => { 
            const blob = new Blob([logArea.textContent], { type: 'text/plain;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'HID-log.log'; 
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            log('日志已导出。', false);
        }); 

        deviceIdInput.addEventListener('change', () => {
            const newIndex = parseInt(deviceIdInput.value);
            selectDevice(newIndex, true); 
        });
        
        enableValidationCheckbox.addEventListener('change', updateDeviceInfoUI);
        dataLengthInput.addEventListener('change', () => {
             const newLength = parseInt(dataLengthInput.value);
             if (isNaN(newLength) || newLength < 1) dataLengthInput.value = 1;
             resetAllIndicators();
             updateAllRowsFormat(false); 
        });
        delayInput.addEventListener('change', () => {
             const newDelay = parseInt(delayInput.value);
             if (isNaN(newDelay) || newDelay < 0) delayInput.value = 0;
        });
        loopCountInput.addEventListener('change', handleLoopControlChange);
        infiniteLoopCheckbox.addEventListener('change', handleLoopControlChange);


        // --- 按钮事件 ---
        addRawDataButton.addEventListener('click', addNewDataRow);
        removeRawDataButton.addEventListener('click', () => deleteDataRow()); 
        sendAllButton.addEventListener('click', sendAllDataWithDelay);
        resetIndicatorsButton.addEventListener('click', resetAllIndicators);
        binaryFormatCheckbox.addEventListener('change', setInputValidation);
        
        // ** 事件委托：处理所有数据行内的点击事件 **
        rawDataContainer.addEventListener('click', (e) => {
            const target = e.target;
            const rowDiv = target.closest('.data-row');
            if (!rowDiv) return;
            
            const index = parseInt(rowDiv.getAttribute('data-index'));

            if (target.classList.contains('send-row-btn')) {
                sendData(index);
            } else if (target.classList.contains('delete-row-btn')) {
                deleteDataRow(index);
            } else if (target.classList.contains('fill-zero-btn')) {
                e.stopPropagation(); 
                fillDataWithZeros(index);
            } else if (target.closest('.data-row') && !target.closest('.actions')) {
                // 点击数据行主体区域（排除按钮区），触发选中
                selectDataRow(index);
            }
        });

    </script>

    <script>
        // Disable right-click menu and F12/Ctrl+Shift+I/Ctrl+U
        document.addEventListener('contextmenu',function(e){e.preventDefault();});
        document.onkeydown = function(e) {
            if (e.keyCode == 123 || (e.ctrlKey && e.shiftKey && e.keyCode == 73) || (e.ctrlKey && e.keyCode == 85)) {
                return false;
            }
            if (e.keyCode == 116) { // Disable F5 (refresh)
                e.preventDefault();
            }
        };
</script>
    
</body>
</html>
